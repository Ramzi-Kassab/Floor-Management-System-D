{% load static %}
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="csrf-token" content="{{ csrf_token }}">
    <title>Cutter Map Editor - ARDT FMS</title>
    <!-- Tabulator Library for MAT Selection Table -->
    <link href="https://unpkg.com/tabulator-tables@5.5.0/dist/css/tabulator_midnight.min.css" rel="stylesheet">
    <script type="text/javascript" src="https://unpkg.com/tabulator-tables@5.5.0/dist/js/tabulator.min.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: Arial, sans-serif; background: #f0f0f0; font-size: 12px; }
        
        .app-header { background: #C8102E; color: white; padding: 10px 20px; }
        .app-header h1 { font-size: 1.2rem; }
        .container { max-width: 1200px; margin: 0 auto; padding: 15px; }
        
        .btn { background: #C8102E; color: white; border: none; padding: 6px 14px; border-radius: 4px; cursor: pointer; font-size: 12px; }
        .btn:hover { background: #a00d24; }
        .btn-green { background: #28a745; }
        .btn-green:hover { background: #1e7e34; }
        .btn-gray { background: #666; }
        .btn-sm { padding: 3px 8px; font-size: 10px; }
        
        .upload-section { background: white; padding: 30px; border-radius: 8px; text-align: center; margin-bottom: 15px; }
        .upload-area { border: 2px dashed #ccc; padding: 40px; border-radius: 8px; cursor: pointer; }
        .upload-area:hover { border-color: #C8102E; background: #fff5f5; }
        
        .hidden { display: none !important; }
        .data-section { display: none; }
        .data-section.active { display: block; }
        
        .tabs { display: flex; gap: 5px; margin-bottom: 15px; background: white; padding: 10px; border-radius: 8px; }
        .tab { padding: 8px 16px; cursor: pointer; border-radius: 4px; font-weight: bold; color: #666; }
        .tab:hover { background: #f0f0f0; }
        .tab.active { background: #C8102E; color: white; }
        .tab-content { display: none; background: white; padding: 15px; border-radius: 8px; }
        .tab-content.active { display: block; }
        
        .stats-row { display: flex; gap: 10px; margin-bottom: 15px; }
        .stat-box { flex: 1; background: #C8102E; color: white; padding: 15px; border-radius: 8px; text-align: center; }
        .stat-box .num { font-size: 24px; font-weight: bold; }
        .stat-box .label { font-size: 11px; opacity: 0.9; }
        
        .form-row { display: flex; gap: 10px; flex-wrap: wrap; margin-bottom: 10px; }
        .form-group { flex: 1; min-width: 150px; }
        .form-group label { display: block; font-weight: bold; margin-bottom: 3px; font-size: 11px; color: #555; }
        .form-group input, .form-group select { width: 100%; padding: 6px; border: 1px solid #ccc; border-radius: 4px; }
        
        table { width: 100%; border-collapse: collapse; }
        th, td { border: 1px solid #333; padding: 6px; text-align: center; }
        th { background: #555; color: white; }
        tr:nth-child(even) { background: #f5f5f5; }
        
        .message { padding: 10px; border-radius: 4px; margin-bottom: 10px; }
        .message.success { background: #d4edda; color: #155724; }
        .message.error { background: #f8d7da; color: #721c24; }
        
        /* ========== DOCUMENT PREVIEW - MATCHING PDF LAYOUT EXACTLY ========== */
        /* PDF sizes: 1190x1684 or 792x1224 - scale proportionally */
        .doc-preview {
            background: white;
            padding: 8px;
            font-family: Arial, sans-serif;
        }

        /* Header frame: Logo left (42%), info right - table layout like PDF */
        .doc-header-frame {
            border: 2px solid #333;
            margin-bottom: 5px;
            display: table;
            width: 100%;
            border-collapse: collapse;
        }
        .doc-header-inner {
            display: table-row;
        }
        .doc-logo {
            display: table-cell;
            width: 42%;
            padding: 4px 8px;
            vertical-align: middle;
            border-right: 2px solid #333;
        }
        .doc-logo img {
            height: 14px;
            width: auto;
        }
        .doc-header-info {
            display: table-cell;
            vertical-align: top;
        }
        .doc-header-row {
            display: flex;
            font-size: 7px;
            border-bottom: 2px solid #333;
        }
        .doc-header-row:last-child {
            border-bottom: none;
        }
        .doc-header-item {
            flex: 1;
            white-space: nowrap;
            border-right: 2px solid #333;
            padding: 3px 6px;
            background: white;
        }
        .doc-header-item:last-child {
            border-right: none;
        }
        .doc-header-label { font-weight: normal; color: #333; }
        .doc-header-value { font-weight: bold; color: #000; }

        /* Content row: BOM + Group Legend + Drill bit preview - matching PDF proportions */
        .doc-content {
            display: flex;
            align-items: flex-start;
            margin-bottom: 8px;
            width: 100%;
        }

        /* BOM Table - 2/3 page width, borderless rows with alternating colors */
        .doc-bom {
            flex: 0 0 66.67%;
            max-width: 66.67%;
        }
        .doc-bom table {
            font-size: 7px;
            border-collapse: collapse;
            width: 100%;
        }
        .doc-bom th {
            background: #555;
            color: white;
            padding: 3px 5px;
            font-size: 6px;
            font-weight: bold;
            text-align: center;
            border: 1px solid #333;
        }
        /* Data rows - NO borders, alternating colors */
        .doc-bom td {
            padding: 2px 4px;
            border: none;
            text-align: center;
        }
        .doc-bom tbody tr:nth-child(odd) {
            background: #ffffff;
        }
        .doc-bom tbody tr:nth-child(even) {
            background: #e8e8e8;
        }

        /* Group Legend - vertical table layout like PDF */
        .doc-group-legend {
            display: table;
            border: 1px solid #999;
            background: #fafafa;
            margin-left: 10px;
            font-size: 7px;
            border-collapse: collapse;
        }
        .group-legend-header {
            display: table-row;
            font-weight: bold;
            font-size: 6px;
            color: #333;
        }
        .group-legend-header-shape,
        .group-legend-header-group {
            display: table-cell;
            padding: 2px 5px;
            text-align: center;
            border-bottom: 1px solid #999;
        }
        .group-legend-row {
            display: table-row;
        }
        .group-legend-cell {
            display: table-cell;
            padding: 2px 5px;
            vertical-align: middle;
            text-align: center;
        }
        .group-legend-cell .group-num {
            font-weight: bold;
            font-size: 11px;
            display: inline;
            min-width: 18px;
        }
        .group-shape-img {
            width: 18px;
            height: 18px;
            object-fit: contain;
            display: block;
            margin: 0 auto;
        }
        .group-values {
            font-size: 7px;
            font-weight: bold;
            min-width: 22px;
            color: #000;
        }

        /* Drill bit preview - far right, sized to match BOM height */
        .doc-drill-preview {
            margin-left: auto;
            background: white;
            display: flex;
            align-items: flex-start;
        }
        .doc-drill-preview img {
            width: 110px;
            height: 110px;
            object-fit: contain;
            background: white;
            border: none;
        }
        
        /* ========== BLADE STYLES - MATCHING PDF EXACTLY ========== */
        .blade-block { margin-bottom: 4px; background: white; border: 2px solid #888; }
        .blade-inner { display: flex; align-items: stretch; }

        /* Blade label (B1, B2, etc.) - gray background like PDF */
        .blade-label {
            width: 26px;
            min-width: 26px;
            background: #808080;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 12px;
            color: white;
        }

        .blade-rows-wrap { flex: 1; display: flex; flex-direction: column; }

        .blade-row { display: flex; align-items: flex-start; min-height: 38px; }
        .row-content-wrap { flex: 1; display: flex; flex-direction: column; }

        /* Row label (R1, R2, etc.) - light gray like PDF */
        .row-label {
            width: 20px;
            min-width: 20px;
            background: #d0d0d0;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 7px;
            color: #333;
            align-self: stretch;
        }

        /* Cutters container - inline with position labels */
        .positions-wrap {
            display: flex;
            flex: 1;
            flex-wrap: nowrap;
            padding: 1px 2px;
            background: white;
            align-items: center;
        }

        /* Position label - vertical text inline with cutters */
        .pos-label {
            writing-mode: vertical-rl;
            transform: rotate(180deg);
            font-size: 5px;
            font-weight: bold;
            color: #333;
            padding: 0 1px;
            margin-right: 1px;
        }

        /* Position label wrapper with hover actions */
        .pos-label-wrapper {
            position: relative;
            display: inline-flex;
            flex-direction: column;
            align-items: center;
        }
        .pos-label-wrapper .pos-label {
            cursor: grab;
            transition: all 0.2s;
            background: transparent;
            border-radius: 2px;
            padding: 2px 1px;
        }
        .pos-label-wrapper .pos-label:hover {
            background: rgba(74, 144, 217, 0.2);
        }
        .pos-label-wrapper .pos-label.dragging {
            opacity: 0.4;
            cursor: grabbing;
        }
        .pos-label-wrapper .pos-label.drag-ghost {
            opacity: 0.3;
            border: 1px dashed #4a90d9;
        }
        .pos-label-wrapper .pos-label.drag-over {
            background: rgba(74, 144, 217, 0.4);
            box-shadow: 0 0 4px #4a90d9;
        }
        /* Position actions popup - appears on hover */
        .pos-actions {
            position: absolute;
            top: -24px;
            left: 50%;
            transform: translateX(-50%);
            display: none;
            background: #333;
            border-radius: 4px;
            padding: 3px;
            gap: 2px;
            z-index: 50;
            white-space: nowrap;
            flex-direction: row;
        }
        .pos-label-wrapper:hover .pos-actions {
            display: flex;
        }
        .pos-action-btn {
            width: 16px;
            height: 16px;
            border: none;
            border-radius: 3px;
            cursor: pointer;
            font-size: 9px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
        }
        .pos-action-btn.move-left { background: #17a2b8; }
        .pos-action-btn.move-right { background: #17a2b8; }
        .pos-action-btn.change-pos { background: #6c757d; font-size: 8px; }
        .pos-action-btn.delete-pos { background: #dc3545; }
        .pos-action-btn:hover { opacity: 0.85; transform: scale(1.1); }
        .pos-action-btn:disabled { opacity: 0.3; cursor: not-allowed; transform: none; }
        /* Position replacement dropdown */
        .pos-dropdown {
            position: absolute;
            top: 100%;
            left: 50%;
            transform: translateX(-50%);
            background: white;
            border: 1px solid #ccc;
            border-radius: 4px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
            z-index: 100;
            padding: 4px 0;
            min-width: 80px;
            display: none;
        }
        .pos-dropdown.visible {
            display: block;
        }
        .pos-dropdown-item {
            padding: 5px 10px;
            cursor: pointer;
            font-size: 10px;
            text-align: center;
        }
        .pos-dropdown-item:hover {
            background: #f0f0f0;
        }
        .pos-dropdown-item.disabled {
            color: #999;
            cursor: not-allowed;
        }
        .pos-dropdown-item.current {
            background: #e3f2fd;
            font-weight: bold;
        }
        .pos-dropdown-header {
            padding: 4px 10px;
            font-size: 9px;
            color: #666;
            border-bottom: 1px solid #eee;
            text-align: center;
        }
        /* Add position button at end of row */
        .add-pos-wrapper {
            display: inline-flex;
            align-items: center;
            margin-left: 4px;
        }
        .add-pos-btn {
            width: 18px;
            height: 18px;
            border: 1px dashed #28a745;
            background: transparent;
            color: #28a745;
            border-radius: 3px;
            cursor: pointer;
            font-size: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .add-pos-btn:hover {
            background: #28a745;
            color: white;
        }
        .add-position-menu {
            position: absolute;
            background: white;
            border: 1px solid #ccc;
            border-radius: 4px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
            z-index: 100;
            padding: 4px 0;
        }
        .add-position-menu-item {
            padding: 6px 12px;
            cursor: pointer;
            font-size: 11px;
        }
        .add-position-menu-item:hover {
            background: #f0f0f0;
        }
        .add-position-menu-item.disabled {
            color: #999;
            cursor: not-allowed;
        }

        /* Individual cutter - compact vertical layout */
        .cutter {
            text-align: center;
            width: 26px;
            min-width: 26px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .cutter-type {
            font-size: 5px;
            color: #333;
            height: 9px;
            line-height: 9px;
            white-space: nowrap;
        }

        .cutter-circle {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            border: 1px solid #333;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 8px;
        }

        /* Circle colors based on GROUP - matching PDF (groups 1-20) */
        .cutter-circle.group-1 { background: #e8e8e8; color: #333; }
        .cutter-circle.group-2 { background: #d0d0d0; color: #333; }
        .cutter-circle.group-3 { background: #b8b8b8; color: #333; }
        .cutter-circle.group-4 { background: #a0a0a0; color: #333; }
        .cutter-circle.group-5 { background: #888888; color: white; }
        .cutter-circle.group-6 { background: #707070; color: white; }
        .cutter-circle.group-7 { background: #585858; color: white; }
        .cutter-circle.group-8 { background: #404040; color: white; }
        .cutter-circle.group-9 { background: #333333; color: white; }
        .cutter-circle.group-10 { background: #c0c0c0; color: #333; }
        .cutter-circle.group-11 { background: #989898; color: #333; }
        .cutter-circle.group-12 { background: #686868; color: white; }
        .cutter-circle.group-13 { background: #505050; color: white; }
        .cutter-circle.group-14 { background: #383838; color: white; }
        .cutter-circle.group-15 { background: #f0f0f0; color: #333; }
        .cutter-circle.group-16 { background: #e0e0e0; color: #333; }
        .cutter-circle.group-17 { background: #d0d0d0; color: #333; }
        .cutter-circle.group-18 { background: #b0b0b0; color: #333; }
        .cutter-circle.group-19 { background: #909090; color: white; }
        .cutter-circle.group-20 { background: #787878; color: white; }

        .cutter-chamfer {
            font-size: 4px;
            color: #333;
            height: 8px;
            line-height: 8px;
            white-space: nowrap;
        }

        /* Cutter shape image (extracted from PDF) */
        .cutter-shape {
            position: relative;
            width: 16px;
            height: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .cutter-shape-img {
            width: 100%;
            height: 100%;
            object-fit: contain;
        }
        .cutter-group-label {
            position: absolute;
            font-weight: bold;
            font-size: 7px;
            color: white;
            text-shadow: 0 0 2px black, 0 0 2px black;
        }

        /* BOM shape image (extracted from PDF) */
        .bom-shape-img {
            width: 14px;
            height: 12px;
            object-fit: contain;
            vertical-align: middle;
            margin-right: 3px;
        }

        /* ========== CUTTER LOCATIONS TAB STYLES ========== */
        .loc-blade-section {
            margin-bottom: 10px;
            border: 1px solid #ddd;
            border-radius: 6px;
            overflow: hidden;
        }
        .loc-blade-header {
            background: #808080;
            color: white;
            padding: 5px 12px;
            font-weight: bold;
            font-size: 13px;
        }
        .loc-row-section {
            border-bottom: 1px solid #eee;
            padding: 6px 12px;
        }
        .loc-row-section:last-child { border-bottom: none; }
        .loc-row-label {
            font-weight: bold;
            color: #555;
            margin-bottom: 4px;
            font-size: 11px;
        }
        .loc-data-row {
            display: flex;
            flex-wrap: nowrap;
            gap: 2px;
            margin-bottom: 2px;
            font-family: monospace;
        }
        .loc-data-row.groups { font-size: 12px; }
        .loc-data-row.positions { font-size: 8px; color: #666; }
        .loc-data-row.symbols { font-size: 12px; font-weight: bold; }

        .loc-item {
            width: 24px;
            min-width: 24px;
            max-width: 24px;
            text-align: center;
            padding: 1px;
        }
        .loc-pos-label {
            display: inline-block;
            width: 24px;
            min-width: 24px;
            max-width: 24px;
            text-align: center;
            font-size: 7px;
            font-weight: bold;
            color: #555;
            overflow: hidden;
            text-overflow: clip;
        }
        .loc-symbol {
            display: inline-block;
            width: 18px;
            height: 18px;
            line-height: 18px;
            text-align: center;
            border-radius: 3px;
            font-weight: bold;
            font-size: 11px;
        }
        .loc-symbol.loc-C { background: #ffcdd2; color: #b71c1c; }
        .loc-symbol.loc-N { background: #c8e6c9; color: #1b5e20; }
        .loc-symbol.loc-S { background: #bbdefb; color: #0d47a1; }
        .loc-symbol.loc-G { background: #fff9c4; color: #f57f17; }
        .loc-symbol.loc-P { background: #e1bee7; color: #6a1b9a; }

        /* ========== EDIT LAYOUT TAB STYLES ========== */
        .edit-layout-container { display: flex; flex-direction: column; gap: 10px; }
        .edit-toolbar { display: flex; gap: 10px; align-items: center; padding: 8px; background: #f5f5f5; border-radius: 6px; flex-wrap: wrap; }
        .edit-toolbar .mode-toggle { display: flex; gap: 5px; }
        .edit-toolbar .mode-btn { padding: 6px 12px; border: 2px solid #ccc; background: white; cursor: pointer; font-weight: bold; }
        .edit-toolbar .mode-btn.active { background: #28a745; color: white; border-color: #28a745; }
        .edit-toolbar .mode-btn:first-child { border-radius: 4px 0 0 4px; }
        .edit-toolbar .mode-btn:last-child { border-radius: 0 4px 4px 0; }
        .edit-toolbar .undo-redo-group { display: flex; gap: 3px; margin-left: 10px; }
        .edit-toolbar .undo-btn, .edit-toolbar .redo-btn { padding: 5px 10px; font-size: 12px; border-radius: 4px; }
        .edit-toolbar .undo-btn:disabled, .edit-toolbar .redo-btn:disabled { opacity: 0.5; cursor: not-allowed; }

        /* ========== FULL PAGE TOOLBAR ========== */
        .fullpage-toolbar { display: flex; gap: 15px; align-items: center; padding: 8px 12px; background: #f8f9fa; border-radius: 6px; margin-bottom: 10px; flex-wrap: wrap; }
        .fullpage-toolbar .view-toggle { display: flex; gap: 0; }
        .fullpage-toolbar .view-btn { padding: 6px 14px; border: 2px solid #0062cc; background: white; cursor: pointer; font-weight: bold; color: #0062cc; }
        .fullpage-toolbar .view-btn.active { background: #0062cc; color: white; }
        .fullpage-toolbar .view-btn:first-child { border-radius: 4px 0 0 4px; }
        .fullpage-toolbar .view-btn:last-child { border-radius: 0 4px 4px 0; border-left: none; }
        .fullpage-toolbar .view-btn:hover:not(.active) { background: #e3f2fd; }
        .view-change-indicator { font-size: 12px; padding: 5px 12px; background: #fff3e0; color: #e65100; border-radius: 12px; font-weight: 500; }
        .view-change-indicator.no-changes { background: #e8f5e9; color: #2e7d32; }

        .edit-validation { padding: 8px 12px; background: #e8f5e9; border-radius: 4px; font-size: 11px; display: flex; gap: 15px; flex-wrap: wrap; }
        .edit-validation.has-errors { background: #ffebee; }
        .validation-item { display: flex; align-items: center; gap: 4px; }
        .validation-item.valid { color: #2e7d32; }
        .validation-item.invalid { color: #c62828; font-weight: bold; }

        .edit-layout-main { display: flex; min-height: 650px; position: relative; }
        .edit-bom-panel { width: 350px; min-width: 200px; max-width: 600px; background: #fafafa; border: 1px solid #ddd; border-radius: 6px; padding: 10px; max-height: 800px; overflow-y: auto; flex-shrink: 0; }
        .edit-cl-panel { flex: 1; min-width: 300px; background: white; border: 1px solid #ddd; border-radius: 6px; padding: 10px; overflow: auto; max-height: 800px; }
        /* Resizer between panels */
        .panel-resizer { width: 8px; background: #e0e0e0; cursor: col-resize; flex-shrink: 0; border-radius: 4px; margin: 0 4px; transition: background 0.2s; display: flex; align-items: center; justify-content: center; }
        .panel-resizer:hover, .panel-resizer.dragging { background: #1976d2; }
        .panel-resizer::after { content: 'â‹®'; color: #666; font-size: 14px; }
        .panel-resizer:hover::after, .panel-resizer.dragging::after { color: white; }

        /* BOM Item Selection */
        .edit-bom-item { padding: 8px; margin-bottom: 6px; border: 2px solid #ddd; border-radius: 6px; cursor: pointer; transition: all 0.2s; }
        .edit-bom-item:hover { border-color: #999; background: #f0f0f0; }
        .edit-bom-item.selected { border-color: #1976d2; background: #e3f2fd; box-shadow: 0 0 5px rgba(25,118,210,0.3); }
        .edit-bom-item.same-size-highlight { border-color: #4caf50; background: #e8f5e9; box-shadow: 0 0 3px rgba(76,175,80,0.3); }
        .cl-mode-indicator { font-size: 11px; padding: 4px 10px; border-radius: 12px; margin-left: 15px; cursor: pointer; user-select: none; transition: all 0.2s; }
        .cl-mode-indicator:hover { opacity: 0.8; transform: scale(1.02); }
        .cl-mode-indicator.active { background: #c8e6c9; color: #2e7d32; border: 2px solid #4caf50; }
        .cl-mode-indicator.inactive { background: #ffcdd2; color: #c62828; border: 2px solid #f44336; }

        /* BOM Fold indicator */
        .bom-fold-indicator { font-size: 10px; padding: 3px 8px; border-radius: 10px; cursor: pointer; user-select: none; transition: all 0.2s; }
        .bom-fold-indicator:hover { opacity: 0.8; transform: scale(1.02); }
        .bom-fold-indicator.active { background: #e3f2fd; color: #1565c0; border: 2px solid #2196f3; }
        .bom-fold-indicator.inactive { background: #f5f5f5; color: #757575; border: 2px solid #bdbdbd; }

        /* Folded BOM items (hidden when fold mode is on and size doesn't match selected) */
        .edit-bom-item.folded-hidden { display: none !important; }

        /* Unassigned cutters */
        .edit-cutter.unassigned { opacity: 0.5; }
        .edit-cutter.unassigned .cutter-circle { background: #9e9e9e !important; border: 2px dashed #616161; }
        .edit-cutter.unassigned .cutter-type { color: #9e9e9e; font-style: italic; font-size: 8px; }
        .bom-item-unassigned { background: #bdbdbd !important; }
        .edit-bom-item.editing { border-color: #ff9800; background: #fff3e0; }
        .edit-bom-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 4px; gap: 8px; }
        .edit-bom-index { font-size: 18px; font-weight: bold; width: 28px; height: 28px; border-radius: 50%; display: flex; align-items: center; justify-content: center; color: white; flex-shrink: 0; }
        .edit-bom-mat { font-size: 11px; font-weight: bold; color: #333; flex: 1; }
        .edit-bom-size-badge { font-size: 10px; font-weight: bold; background: #607d8b; color: white; padding: 2px 6px; border-radius: 10px; }
        .edit-bom-details { display: flex; gap: 8px; font-size: 10px; color: #666; flex-wrap: wrap; }
        .edit-bom-qty { font-weight: bold; padding: 2px 6px; background: #e0e0e0; border-radius: 3px; }
        .edit-bom-actions { margin-top: 6px; display: flex; gap: 4px; flex-wrap: wrap; align-items: center; }
        .edit-bom-actions select { font-size: 10px; padding: 3px 6px; border: 1px solid #ccc; border-radius: 3px; }
        .edit-bom-actions button { font-size: 10px; padding: 3px 8px; border: 1px solid #ccc; border-radius: 3px; cursor: pointer; }

        /* Fill Options Panel */
        .fill-options-panel {
            position: absolute; top: 100%; left: 0; background: white; border: 1px solid #ccc;
            border-radius: 6px; box-shadow: 0 4px 12px rgba(0,0,0,0.2); padding: 10px;
            min-width: 280px; z-index: 1000; display: none;
        }
        .fill-options-panel.show { display: block; }
        .fill-options-panel h4 { margin: 0 0 8px 0; font-size: 12px; color: #333; border-bottom: 1px solid #eee; padding-bottom: 5px; }
        .fill-options-group { margin-bottom: 10px; }
        .fill-options-group-label { font-size: 10px; color: #666; font-weight: bold; margin-bottom: 4px; }
        .fill-options-row { display: flex; flex-wrap: wrap; gap: 4px; }
        .fill-checkbox-label {
            display: flex; align-items: center; gap: 4px; font-size: 10px; padding: 3px 8px;
            background: #f5f5f5; border-radius: 3px; cursor: pointer; transition: all 0.15s;
        }
        .fill-checkbox-label:hover { background: #e0e0e0; }
        .fill-checkbox-label input { margin: 0; }
        .fill-checkbox-label.checked { background: #bbdefb; }
        .fill-apply-btn {
            width: 100%; margin-top: 10px; padding: 6px 12px; background: #4CAF50; color: white;
            border: none; border-radius: 4px; font-size: 11px; font-weight: bold; cursor: pointer;
        }
        .fill-apply-btn:hover { background: #388E3C; }
        .fill-apply-btn:disabled { background: #ccc; cursor: not-allowed; }

        /* Interactive Cutter Circles */
        .edit-cutter { cursor: pointer; transition: all 0.15s; position: relative; }
        .edit-cutter:hover { transform: scale(1.1); z-index: 10; }
        .edit-cutter.assigned { }
        .edit-cutter.available { opacity: 0.6; }
        .edit-cutter.available:hover { opacity: 1; }
        .edit-cutter.invalid-size { opacity: 0.3; cursor: not-allowed; }
        .edit-cutter.highlight { animation: pulse 0.5s ease-in-out infinite alternate; }
        @keyframes pulse { from { transform: scale(1); } to { transform: scale(1.15); } }

        /* Cutter Options Dropdown */
        .cutter-options { position: absolute; top: 100%; left: 50%; transform: translateX(-50%); background: white; border: 1px solid #333; border-radius: 4px; box-shadow: 0 3px 10px rgba(0,0,0,0.2); z-index: 100; min-width: 120px; font-size: 10px; }
        .cutter-options.hidden { display: none; }
        .cutter-option { padding: 6px 10px; cursor: pointer; white-space: nowrap; }
        .cutter-option:hover { background: #e3f2fd; }
        .cutter-option.selected { background: #1976d2; color: white; }
        .cutter-option-header { padding: 4px 10px; background: #f5f5f5; font-weight: bold; border-bottom: 1px solid #ddd; }

        /* Color coding for BOM items (up to 9 items) */
        .bom-color-1 { background: #e53935; } /* Red */
        .bom-color-2 { background: #1e88e5; } /* Blue */
        .bom-color-3 { background: #43a047; } /* Green */
        .bom-color-4 { background: #fb8c00; } /* Orange */
        .bom-color-5 { background: #8e24aa; } /* Purple */
        .bom-color-6 { background: #00acc1; } /* Cyan */
        .bom-color-7 { background: #d81b60; } /* Pink */
        .bom-color-8 { background: #6d4c41; } /* Brown */
        .bom-color-9 { background: #546e7a; } /* Blue Grey */

        .cutter-circle.bom-item-1 { background: #e53935 !important; }
        .cutter-circle.bom-item-2 { background: #1e88e5 !important; }
        .cutter-circle.bom-item-3 { background: #43a047 !important; }
        .cutter-circle.bom-item-4 { background: #fb8c00 !important; }
        .cutter-circle.bom-item-5 { background: #8e24aa !important; }
        .cutter-circle.bom-item-6 { background: #00acc1 !important; }
        .cutter-circle.bom-item-7 { background: #d81b60 !important; }
        .cutter-circle.bom-item-8 { background: #6d4c41 !important; }
        .cutter-circle.bom-item-9 { background: #546e7a !important; }

        /* Position indicator colors removed - using separators instead */

        /* Review mode hides edit controls */
        .review-mode .edit-bom-actions { display: none; }
        .review-mode .edit-cutter { cursor: default; }
        .review-mode .edit-cutter:hover { transform: none; }

        /* MAT Input Dialog */
        .mat-dialog { position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.5); display: flex; align-items: center; justify-content: center; z-index: 1000; }
        .mat-dialog.hidden { display: none; }
        .mat-dialog-box { background: white; padding: 20px; border-radius: 8px; min-width: 350px; }
        .mat-dialog-title { font-size: 16px; font-weight: bold; margin-bottom: 15px; }
        .mat-dialog-input { width: 100%; padding: 10px; font-size: 14px; border: 1px solid #ccc; border-radius: 4px; margin-bottom: 15px; }
        .mat-dialog-buttons { display: flex; gap: 10px; justify-content: flex-end; }

        /* Delete BOM Dialog Options */
        .delete-options { display: flex; flex-direction: column; gap: 10px; }
        .delete-option-btn { display: flex; align-items: center; gap: 12px; padding: 12px 15px; border: 2px solid #ddd; border-radius: 8px; background: #f8f9fa; cursor: pointer; text-align: left; transition: all 0.2s; }
        .delete-option-btn:hover { border-color: #888; background: #fff; }
        .delete-option-btn .option-icon { font-size: 24px; width: 40px; text-align: center; }
        .delete-option-btn .option-text { flex: 1; }
        .delete-option-btn .option-text strong { display: block; font-size: 13px; color: #333; margin-bottom: 3px; }
        .delete-option-btn .option-text small { display: block; font-size: 11px; color: #666; }
        .delete-option-btn.placeholder-btn:hover { border-color: #dc3545; background: #fff5f5; }
        .delete-option-btn.placeholder-btn .option-icon { color: #dc3545; font-weight: bold; font-size: 28px; }
        .delete-option-btn.remove-btn:hover { border-color: #6c757d; background: #f5f5f5; }

        /* Editor specific */
        .blade-toolbar { background: #e0e0e0; padding: 5px; border-bottom: 1px solid #333; display: flex; gap: 5px; align-items: center; flex-wrap: wrap; }
        .blade-toolbar select, .blade-toolbar input { padding: 3px; font-size: 10px; }

        .cutter:hover { background: #fffde7; border-radius: 4px; }
        .cutter.replaceable { outline: 2px dashed #17a2b8; cursor: pointer; }
        .cutter.replaceable:hover { background: #e3f2fd; }

        /* ========== ENHANCED BLADE EDITOR STYLES ========== */
        /* Foldable Sections */
        .cl-section { margin-bottom: 12px; background: #f8f9fa; border: 1px solid #ddd; border-radius: 6px; overflow: hidden; }
        .cl-section-header { display: flex; align-items: center; gap: 8px; padding: 8px 12px; background: linear-gradient(135deg, #555, #666); color: white; cursor: pointer; user-select: none; }
        .cl-section-header:hover { background: linear-gradient(135deg, #666, #777); }
        .cl-section-header h4 { margin: 0; font-size: 12px; font-weight: 600; }
        .cl-section-header-simple { display: flex; align-items: center; gap: 8px; padding: 8px 12px; background: linear-gradient(135deg, #555, #666); color: white; }
        .cl-section-header-simple h4 { margin: 0; font-size: 12px; font-weight: 600; }
        .cl-section-toggle { font-size: 10px; transition: transform 0.2s; }
        .cl-section.folded .cl-section-toggle { transform: rotate(-90deg); }
        .cl-section-content { padding: 10px 12px; }
        .cl-section.folded .cl-section-content { display: none; }

        /* BOM Toolbar */
        .bom-toolbar { display: flex; align-items: center; gap: 15px; margin-bottom: 10px; padding: 8px; background: #f0f0f0; border-radius: 4px; flex-wrap: wrap; }
        .bom-mode-buttons { display: flex; gap: 5px; }
        .bom-mode-btn { padding: 5px 10px; border: 1px solid #999; border-radius: 4px; background: white; cursor: pointer; font-size: 11px; display: flex; align-items: center; gap: 4px; transition: all 0.2s; }
        .bom-mode-btn:hover { background: #e8e8e8; }
        .bom-mode-btn.active { background: #28a745; color: white; border-color: #28a745; }
        .bom-mode-btn.active.replace { background: #17a2b8; border-color: #17a2b8; }
        .bom-mode-btn .mode-icon { font-weight: bold; }
        .bom-selected-info { font-size: 11px; color: #333; display: flex; align-items: center; gap: 8px; }

        /* BOM Merged Table */
        .bom-merged-table { width: 100%; border-collapse: collapse; font-size: 10px; }
        .bom-merged-table th { background: #444; color: white; padding: 5px 6px; text-align: center; font-weight: 600; }
        .bom-merged-table td { padding: 4px 6px; text-align: center; border-bottom: 1px solid #e0e0e0; }
        .bom-merged-table tr:nth-child(even) { background: #f5f5f5; }
        .bom-merged-table tr:hover { background: #e8f5e9; }
        .bom-merged-table tr.bom-selected { background: #c8e6c9 !important; }
        .bom-merged-table tr.bom-dragging { opacity: 0.4; }
        .bom-merged-table tr.bom-drag-over { border-top: 3px solid #2196f3; }
        .bom-merged-table .count-match { color: #28a745; font-weight: bold; }
        .bom-merged-table .count-less { color: #dc3545; font-weight: bold; }
        .bom-merged-table .count-more { color: #007bff; font-weight: bold; }
        .bom-merged-table .bom-actions { display: flex; gap: 3px; justify-content: center; }
        .bom-merged-table .bom-action-btn { width: 20px; height: 20px; border: none; border-radius: 3px; cursor: pointer; font-size: 10px; color: white; }
        .bom-merged-table .bom-action-btn.select { background: #28a745; }
        .bom-merged-table .bom-action-btn.edit { background: #17a2b8; }
        .bom-merged-table .bom-action-btn.delete { background: #dc3545; }
        .bom-merged-table .bom-action-btn:hover { opacity: 0.85; }
        .bom-merged-table .bom-drag-handle { cursor: grab; color: #999; font-size: 12px; }
        .bom-merged-table .bom-drag-handle:hover { color: #333; }
        .bom-shape-cell { display: flex; align-items: center; justify-content: center; gap: 4px; }
        .bom-shape-preview { width: 24px; height: 24px; object-fit: contain; border: 1px solid #ddd; border-radius: 3px; background: white; }
        .bom-shape-empty { color: #ccc; font-size: 14px; }
        .bom-shape-upload { cursor: pointer; font-size: 12px; opacity: 0.6; transition: opacity 0.2s; }
        .bom-shape-upload:hover { opacity: 1; }
        .editor-toolbar .current-cutter { display: flex; align-items: center; gap: 8px; background: #fff; padding: 5px 12px; border-radius: 4px; border: 1px solid #ccc; }
        .editor-toolbar .current-cutter-preview { width: 20px; height: 20px; border-radius: 50%; background: #e8e8e8; display: flex; align-items: center; justify-content: center; font-size: 10px; font-weight: bold; }

        /* Cutter with actions */
        .cutter-wrapper { position: relative; display: inline-flex; flex-direction: column; align-items: center; }
        .cutter-actions { position: absolute; top: -20px; left: 50%; transform: translateX(-50%); display: none; background: #333; border-radius: 4px; padding: 3px; gap: 2px; z-index: 10; white-space: nowrap; }
        .cutter-wrapper:hover .cutter-actions { display: flex; }
        .cutter-action-btn { width: 18px; height: 18px; border: none; border-radius: 3px; cursor: pointer; font-size: 10px; display: flex; align-items: center; justify-content: center; color: white; position: relative; }
        .cutter-action-btn.add-left { background: #28a745; }
        .cutter-action-btn.add-right { background: #28a745; }
        .cutter-action-btn.clone { background: #17a2b8; }
        .cutter-action-btn.delete { background: #dc3545; }
        .cutter-action-btn.edit { background: #ffc107; color: #333; }
        .cutter-action-btn:hover { opacity: 0.85; transform: scale(1.1); }
        /* Clone button glow when clipboard has content */
        .cutter-action-btn.clone.has-clipboard { animation: clipboardGlow 1s ease-in-out infinite; }
        /* Add buttons glow when clipboard has content (paste mode) */
        .cutter-action-btn.add-left.has-clipboard, .cutter-action-btn.add-right.has-clipboard { animation: addPasteGlow 1s ease-in-out infinite; }
        @keyframes clipboardGlow { 0%, 100% { box-shadow: 0 0 4px #17a2b8; } 50% { box-shadow: 0 0 10px #17a2b8, 0 0 15px #17a2b8; } }
        @keyframes addPasteGlow { 0%, 100% { box-shadow: 0 0 4px #28a745; } 50% { box-shadow: 0 0 10px #28a745, 0 0 15px #28a745; } }
        /* Tooltip for clipboard content */
        .cutter-action-btn .tooltip { position: absolute; bottom: 100%; left: 50%; transform: translateX(-50%); background: #222; color: #fff; padding: 4px 8px; border-radius: 4px; font-size: 9px; white-space: nowrap; margin-bottom: 5px; display: none; z-index: 100; }
        .cutter-action-btn:hover .tooltip { display: block; }

        /* Draggable cutter */
        .cutter.draggable { cursor: grab; }
        .cutter.draggable:active { cursor: grabbing; }
        .cutter.dragging { opacity: 0.4; transform: scale(0.95); }

        /* Draggable row */
        .draggable-row { transition: all 0.2s; }
        .draggable-row .row-drag-handle { cursor: grab; user-select: none; }
        .draggable-row.dragging-row { opacity: 0.4; background: #e3f2fd; }
        .draggable-row.row-drag-over { background: rgba(33, 150, 243, 0.2); border: 2px dashed #2196f3; }
        .row-drag-mode .draggable-row { border: 1px dashed #ccc; margin: 2px 0; }

        /* Draggable blade */
        .draggable-blade { transition: all 0.2s; }
        .blade-drag-handle { cursor: grab; margin-right: 8px; font-size: 14px; color: #666; user-select: none; }
        .blade-drag-handle:hover { color: #333; }
        .draggable-blade.dragging-blade { opacity: 0.4; transform: scale(0.98); }
        .draggable-blade.blade-drag-over { background: rgba(156, 39, 176, 0.1); border: 2px dashed #9c27b0; }
        .blade-drag-mode .draggable-blade { border: 1px dashed #ccc; margin: 4px 0; }

        /* Insert mode - shows drop zones when adding/cloning */
        .insert-mode .drop-zone { display: inline-flex !important; }
        .drop-zone { display: none; width: 8px; height: 38px; margin: 0 1px; border-radius: 3px; align-items: center; justify-content: center; transition: all 0.15s; }
        .drop-zone:hover, .drop-zone.drag-over { background: rgba(76, 175, 80, 0.3); width: 20px; cursor: pointer; }
        .drop-zone:hover::after { content: '+'; color: #4CAF50; font-weight: bold; font-size: 14px; }

        /* Row actions */
        .row-actions { display: flex; align-items: center; gap: 3px; margin-left: 8px; }
        .row-action-btn { width: 18px; height: 18px; border: none; border-radius: 3px; cursor: pointer; font-size: 10px; display: flex; align-items: center; justify-content: center; color: white; }
        .row-action-btn.add-row { background: #28a745; }
        .row-action-btn.add-row.has-clipboard { animation: addPasteGlow 1s ease-in-out infinite; }
        .row-action-btn.clone-row { background: #17a2b8; }
        .row-action-btn.clone-row.has-clipboard { animation: clipboardGlow 1s ease-in-out infinite; }
        .row-action-btn.delete { background: #dc3545; }
        .row-action-btn:hover { opacity: 0.85; transform: scale(1.1); }

        /* Blade toolbar actions */
        .blade-toolbar .blade-action-btn { padding: 3px 8px; font-size: 10px; border: none; border-radius: 3px; cursor: pointer; margin-left: 5px; }
        .blade-toolbar .blade-action-btn.clone-blade { background: #17a2b8; color: white; }
        .blade-toolbar .blade-action-btn.remove-blade { background: #dc3545; color: white; }
        .blade-toolbar .blade-action-btn:hover { opacity: 0.85; }

        /* New cutter glow animation */
        @keyframes cutterGlow {
            0% { box-shadow: 0 0 5px #4CAF50, 0 0 10px #4CAF50, 0 0 15px #4CAF50; }
            50% { box-shadow: 0 0 10px #4CAF50, 0 0 20px #4CAF50, 0 0 30px #4CAF50; }
            100% { box-shadow: 0 0 5px #4CAF50, 0 0 10px #4CAF50, 0 0 15px #4CAF50; }
        }
        .cutter.new-cutter { animation: cutterGlow 0.5s ease-in-out 3; border-radius: 4px; }

        /* Placeholder cutter - continuous RED glow until assigned */
        @keyframes placeholderGlow {
            0%, 100% { box-shadow: 0 0 5px #dc3545, 0 0 10px #dc3545; background: #ffebee; }
            50% { box-shadow: 0 0 10px #dc3545, 0 0 20px #dc3545, 0 0 30px #dc3545; background: #ffcdd2; }
        }
        .cutter.placeholder-cutter {
            animation: placeholderGlow 1.5s ease-in-out infinite;
            border: 2px dashed #dc3545;
            border-radius: 4px;
            cursor: pointer;
        }
        .cutter.placeholder-cutter .cutter-circle {
            background: #ffebee;
            border: 2px dashed #dc3545;
            color: #dc3545;
            font-weight: bold;
        }

        /* Insert mode indicator */
        .insert-indicator { position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%); background: #333; color: white; padding: 10px 20px; border-radius: 6px; font-size: 12px; z-index: 1000; display: none; box-shadow: 0 4px 12px rgba(0,0,0,0.3); }
        .insert-indicator.active { display: flex; align-items: center; gap: 10px; }
        .insert-indicator .cancel-btn { background: #dc3545; border: none; color: white; padding: 4px 10px; border-radius: 3px; cursor: pointer; font-size: 11px; }
        
        .action-bar { display: flex; gap: 10px; margin-top: 15px; padding-top: 15px; border-top: 1px solid #ddd; }
        
        /* Modal */
        .modal { display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.5); z-index: 1000; align-items: center; justify-content: center; }
        .modal.active { display: flex; }
        .modal-box { background: white; padding: 20px; border-radius: 8px; max-width: 450px; width: 90%; }
        .modal-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px; border-bottom: 1px solid #ddd; padding-bottom: 10px; }
        .modal-close { background: none; border: none; font-size: 20px; cursor: pointer; }

        /* Shape edit container */
        .shape-edit-container { display: flex; align-items: center; gap: 10px; padding: 8px; border: 1px solid #ddd; border-radius: 6px; background: #f9f9f9; }
        .shape-preview { width: 60px; height: 60px; border: 1px dashed #ccc; border-radius: 4px; display: flex; align-items: center; justify-content: center; background: white; overflow: hidden; }
        .shape-preview img { max-width: 100%; max-height: 100%; object-fit: contain; }
        .shape-preview .shape-placeholder { color: #aaa; font-size: 10px; text-align: center; }
        .shape-actions { display: flex; flex-direction: column; gap: 5px; }
        .shape-actions .btn-sm { padding: 4px 10px; font-size: 11px; }

        /* MAT Selection Table Dialog with Tabulator */
        .mat-table-dialog { position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.7); display: flex; align-items: center; justify-content: center; z-index: 1100; }
        .mat-table-dialog.hidden { display: none; }
        .mat-table-box { background: white; padding: 0; border-radius: 12px; max-width: 900px; width: 95%; max-height: 85vh; display: flex; flex-direction: column; box-shadow: 0 10px 40px rgba(0,0,0,0.3); overflow: hidden; }
        .mat-table-header { display: flex; justify-content: space-between; align-items: center; padding: 15px 20px; background: linear-gradient(135deg, #1565c0 0%, #1976d2 50%, #42a5f5 100%); color: white; }
        .mat-table-header-left { display: flex; align-items: center; gap: 12px; }
        .mat-table-title { font-size: 18px; font-weight: 600; letter-spacing: 0.5px; }
        .mat-table-subtitle { font-size: 11px; opacity: 0.9; }
        .mat-size-locked { background: rgba(255,255,255,0.2); color: white; font-size: 11px; padding: 4px 10px; border-radius: 15px; border: 1px solid rgba(255,255,255,0.3); }
        .mat-size-unlock-btn { background: rgba(255,255,255,0.25); color: white; border: 1px solid rgba(255,255,255,0.4); padding: 4px 10px; border-radius: 15px; cursor: pointer; font-size: 10px; transition: all 0.2s; }
        .mat-size-unlock-btn:hover { background: rgba(255,255,255,0.35); }
        .mat-table-close-btn { background: rgba(255,255,255,0.2); border: none; width: 32px; height: 32px; border-radius: 50%; font-size: 18px; cursor: pointer; color: white; transition: all 0.2s; display: flex; align-items: center; justify-content: center; }
        .mat-table-close-btn:hover { background: rgba(255,255,255,0.35); transform: scale(1.1); }
        .mat-table-container { flex: 1; min-height: 350px; overflow: hidden; padding: 15px 20px; }
        .mat-table-footer { display: flex; justify-content: space-between; align-items: center; padding: 12px 20px; background: #f5f5f5; border-top: 1px solid #e0e0e0; }
        .mat-table-info { font-size: 12px; color: #666; display: flex; align-items: center; gap: 10px; }
        .mat-table-info-count { background: #e3f2fd; padding: 3px 8px; border-radius: 10px; color: #1565c0; font-weight: 500; }
        .mat-table-info-selected { color: #2e7d32; font-weight: 500; }
        .mat-table-buttons { display: flex; gap: 10px; }
        .mat-table-buttons .btn { padding: 8px 20px; border-radius: 6px; font-weight: 500; transition: all 0.2s; }
        .mat-table-buttons .btn-gray { background: #e0e0e0; color: #424242; border: none; }
        .mat-table-buttons .btn-gray:hover { background: #bdbdbd; }
        .mat-table-buttons .btn-green { background: #4caf50; color: white; border: none; transition: all 0.2s; }
        .mat-table-buttons .btn-green:hover:not(:disabled) { background: #43a047; transform: translateY(-1px); }
        .mat-table-buttons .btn-green:disabled { background: #9e9e9e !important; color: #e0e0e0; cursor: not-allowed; opacity: 0.7; }
        /* Tabulator theme overrides */
        #matTabulatorTable { border-radius: 8px; overflow: hidden; border: 1px solid #e0e0e0; }
        #matTabulatorTable .tabulator-header { background: linear-gradient(180deg, #37474f 0%, #263238 100%); border-bottom: 2px solid #1976d2; }
        #matTabulatorTable .tabulator-col { border-right: 1px solid rgba(255,255,255,0.1); }
        #matTabulatorTable .tabulator-col-title { color: white; font-weight: 600; font-size: 12px; padding: 10px 5px; }
        #matTabulatorTable .tabulator-header-filter { padding: 5px; }
        #matTabulatorTable .tabulator-header-filter input,
        #matTabulatorTable .tabulator-header-filter select { font-size: 11px; padding: 4px 6px; border-radius: 4px; border: 1px solid #90a4ae; width: 100%; box-sizing: border-box; }
        #matTabulatorTable .tabulator-header-filter select { cursor: pointer; background: white; }
        #matTabulatorTable .tabulator-row { border-bottom: 1px solid #f0f0f0; }
        #matTabulatorTable .tabulator-row.tabulator-selected { background: #c8e6c9 !important; border-left: 4px solid #4caf50; }
        #matTabulatorTable .tabulator-row:hover { background: #e3f2fd; cursor: pointer; }
        #matTabulatorTable .tabulator-cell { padding: 10px 8px; font-size: 12px; }
    </style>
</head>
<body>
    <div class="app-header" style="display: flex; align-items: center; justify-content: space-between;">
        <div style="display: flex; align-items: center; gap: 15px;">
            <a href="/" title="Back to Home" style="color: white; text-decoration: none; display: flex; align-items: center; padding: 6px 10px; background: rgba(255,255,255,0.15); border-radius: 4px;">
                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M19 12H5M12 19l-7-7 7-7"/>
                </svg>
            </a>
            <h1>HALLIBURTON PDF Generator</h1>
        </div>
        <div style="display: flex; gap: 10px; align-items: center;">
            {% if not design_context %}
            <a href="{% url 'technology:bom_create' %}" style="color: white; text-decoration: none; font-size: 12px; padding: 6px 12px; background: rgba(255,255,255,0.15); border-radius: 4px;">
                Create BOM from Design
            </a>
            {% endif %}
            <a href="{% url 'technology:bom_list' %}" style="color: white; text-decoration: none; font-size: 12px; padding: 6px 12px; background: rgba(255,255,255,0.15); border-radius: 4px;">
                View All BOMs
            </a>
        </div>
    </div>

    {% if design_context %}
    <!-- Design Context Banner - Shown when coming from BOM Create -->
    <div style="background: linear-gradient(90deg, #1e3a5f, #2d5a87); color: white; padding: 12px 20px; margin-bottom: 0;">
        <div style="max-width: 1200px; margin: 0 auto; display: flex; align-items: center; justify-content: space-between;">
            <div style="display: flex; align-items: center; gap: 15px;">
                <span style="background: rgba(255,255,255,0.2); padding: 4px 10px; border-radius: 4px; font-size: 11px; font-weight: bold;">
                    IMPORTING FOR DESIGN
                </span>
                <div style="display: flex; gap: 20px; font-size: 13px;">
                    <span><strong>MAT:</strong> {{ design_context.design_mat }}</span>
                    <span><strong>HDBS:</strong> {{ design_context.design_hdbs }}</span>
                    <span><strong>Size:</strong> {{ design_context.design_size }}</span>
                </div>
            </div>
            <a href="{% url 'technology:bom_create' %}"
               style="background: rgba(255,255,255,0.2); color: white; text-decoration: none; padding: 6px 12px; border-radius: 4px; font-size: 11px;">
                â† Back to BOM Create
            </a>
        </div>
    </div>
    <input type="hidden" id="designId" value="{{ design_context.design_id }}">
    <input type="hidden" id="designMat" value="{{ design_context.design_mat }}">
    <input type="hidden" id="designHdbs" value="{{ design_context.design_hdbs }}">
    <input type="hidden" id="designSize" value="{{ design_context.design_size }}">
    {% else %}
    <!-- Standalone Mode - Hidden inputs for context -->
    <input type="hidden" id="designId" value="">
    <input type="hidden" id="designMat" value="">
    <input type="hidden" id="designHdbs" value="">
    <input type="hidden" id="designSize" value="">
    <input type="hidden" id="standaloneMode" value="true">
    {% endif %}

    <div class="container">
        <!-- Upload -->
        <div class="upload-section" id="uploadSection">
            <div class="upload-area" id="uploadArea">
                <p style="font-size:40px; margin-bottom:10px;">ðŸ“„</p>
                <p>Drag & drop Halliburton PDF here or click to select</p>
                <input type="file" id="fileInput" accept=".pdf" style="display:none;">
                <button class="btn" style="margin-top:15px;" onclick="document.getElementById('fileInput').click()">Select File</button>
            </div>
        </div>
        
        <!-- Data Section -->
        <div class="data-section" id="dataSection">
            <div class="stats-row">
                <div class="stat-box"><div class="num" id="statBlades">0</div><div class="label">Blades</div></div>
                <div class="stat-box"><div class="num" id="statCutters">0</div><div class="label">Total Cutters</div></div>
                <div class="stat-box"><div class="num" id="statTypes">0</div><div class="label">Cutter Types</div></div>
            </div>
            
            <div class="tabs">
                <div class="tab active" data-tab="fullpage">Full Page</div>
                <div class="tab" data-tab="editlayout" style="background:#28a745; color:white;">Edit Layout</div>
                <div class="tab" data-tab="blades">Deep Edit</div>
                <div class="tab" data-tab="locations">Pockets Locations</div>
            </div>
            
            <!-- Full Page Tab -->
            <div class="tab-content active" id="tab-fullpage">
                <div class="fullpage-toolbar">
                    <div class="view-toggle">
                        <button class="view-btn active" data-view="original" onclick="setFullPageView('original')">Original BOM</button>
                        <button class="view-btn" data-view="modified" onclick="setFullPageView('modified')">Modified BOM</button>
                    </div>
                    <span id="viewChangeIndicator" class="view-change-indicator" style="display:none;">
                        Changes from original: <strong id="viewChangeCount">0</strong> modifications
                    </span>
                </div>
                <div class="doc-preview" id="docPreview"></div>
            </div>

            <!-- Edit Layout Tab -->
            <div class="tab-content" id="tab-editlayout">
                <div class="edit-layout-container" id="editLayoutContainer">
                    <!-- Toolbar -->
                    <div class="edit-toolbar">
                        <div class="mode-toggle">
                            <button class="mode-btn active" onclick="setEditMode('edit')">Edit Mode</button>
                            <button class="mode-btn" onclick="setEditMode('review')">Review Mode</button>
                        </div>
                        <div class="undo-redo-group">
                            <button class="btn btn-sm undo-btn" onclick="undoEdit()" title="Undo (Ctrl+Z)" disabled>â†¶ Undo</button>
                            <button class="btn btn-sm redo-btn" onclick="redoEdit()" title="Redo (Ctrl+Y)" disabled>â†· Redo</button>
                        </div>
                        <span id="clDrivenModeIndicator" class="cl-mode-indicator" onclick="toggleClDrivenMode()" title="Click to toggle CL-Driven mode">
                            CL-Driven: <strong id="clDrivenModeStatus">OFF</strong>
                        </span>
                        <div style="flex:1;"></div>
                        <button class="btn btn-green" onclick="showMatDialog()">Set New MAT ID</button>
                        <span style="font-size:11px; color:#666;">New MAT: <strong id="newMatDisplay">Not set</strong></span>
                    </div>

                    <!-- Validation Summary -->
                    <div class="edit-validation" id="editValidation">
                        <span style="font-weight:bold;">Validation:</span>
                        <div id="editValidationItems"></div>
                    </div>

                    <!-- Main Layout: BOM Panel + Resizer + CL Panel -->
                    <div class="edit-layout-main" id="editLayoutMain">
                        <!-- BOM Panel (Left) -->
                        <div class="edit-bom-panel" id="editBomPanel">
                            <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:10px;">
                                <h4 style="font-size:12px; color:#333; margin:0;">BOM Items - Click to Select</h4>
                                <span id="bomFoldIndicator" class="bom-fold-indicator" onclick="toggleBomFold()" title="Click to toggle - Show only same-size BOM items when one is selected">
                                    Fold: <strong id="bomFoldStatus">OFF</strong>
                                </span>
                            </div>
                            <div id="editBomList"></div>
                            <div style="margin-top:10px; padding-top:10px; border-top:1px solid #ddd;">
                                <button class="btn btn-sm" onclick="addNewBomItem()">+ Add New Item</button>
                            </div>
                        </div>

                        <!-- Resizer -->
                        <div class="panel-resizer" id="panelResizer" title="Drag to resize panels"></div>

                        <!-- CL Panel (Right) -->
                        <div class="edit-cl-panel" id="editClPanel">
                            <h4 style="margin-bottom:10px; font-size:12px; color:#333;">Cutter Layout - Click to Assign</h4>
                            <p style="font-size:10px; color:#666; margin-bottom:10px;">
                                <strong>Legend:</strong>
                                <span style="display:inline-block; width:12px; height:12px; background:#ef9a9a; margin:0 2px;"></span>CONE
                                <span style="display:inline-block; width:12px; height:12px; background:#a5d6a7; margin:0 2px;"></span>NOSE
                                <span style="display:inline-block; width:12px; height:12px; background:#90caf9; margin:0 2px;"></span>SHOULDER
                                <span style="display:inline-block; width:12px; height:12px; background:#fff59d; margin:0 2px;"></span>GAUGE
                                <span style="display:inline-block; width:12px; height:12px; background:#ce93d8; margin:0 2px;"></span>PAD
                            </p>
                            <div id="editClContent"></div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Deep Edit Tab -->
            <div class="tab-content" id="tab-blades">
                <!-- Undo/Redo Toolbar for Deep Edit -->
                <div class="deep-edit-toolbar" style="display:flex; align-items:center; gap:10px; padding:8px; background:#f8f9fa; border-radius:4px; margin-bottom:10px;">
                    <div style="display:flex; gap:5px;">
                        <button class="btn btn-sm deep-undo-btn" onclick="undoEdit()" title="Undo (Ctrl+Z)" disabled style="padding:5px 12px;">â†¶ Undo</button>
                        <button class="btn btn-sm deep-redo-btn" onclick="redoEdit()" title="Redo (Ctrl+Y)" disabled style="padding:5px 12px;">â†· Redo</button>
                    </div>
                    <span style="font-size:10px; color:#666;" id="deepEditHistoryInfo">No changes</span>
                </div>
                <!-- Header Section (Foldable) -->
                <div class="cl-section" id="headerSection">
                    <div class="cl-section-header" onclick="toggleSection('header')">
                        <span class="cl-section-toggle" id="headerToggle">â–¼</span>
                        <h4>Document Header</h4>
                    </div>
                    <div class="cl-section-content" id="headerContent">
                        <div class="form-row">
                            <div class="form-group"><label>SN Number</label><input type="text" id="snNumber" value="0"></div>
                            <div class="form-group"><label>Mat Number</label><input type="text" id="matNumber"></div>
                            <div class="form-group"><label>Date Created</label><input type="text" id="dateCreated"></div>
                        </div>
                        <div class="form-row">
                            <div class="form-group"><label>Revision Level</label><input type="text" id="revisionLevel" value="D - 390254"></div>
                            <div class="form-group"><label>Software Version</label><input type="text" id="softwareVersion" value="1.0.9200.39438"></div>
                        </div>
                    </div>
                </div>

                <!-- BOM Section (Foldable) -->
                <div class="cl-section" id="bomSection">
                    <div class="cl-section-header" onclick="toggleSection('bom')">
                        <span class="cl-section-toggle" id="bomToggle">â–¼</span>
                        <h4>Bill of Materials</h4>
                        <div style="margin-left:auto; display:flex; gap:5px;" onclick="event.stopPropagation();">
                            <button class="btn btn-sm" style="background:#6c757d;" onclick="reindexBom()" title="Re-index BOM starting from 1">Re-index</button>
                            <button class="btn btn-green btn-sm" onclick="addNewBomItem()">+ Add New Item</button>
                        </div>
                    </div>
                    <div class="cl-section-content" id="bomContent">
                        <!-- BOM Toolbar -->
                        <div class="bom-toolbar" id="bomToolbar">
                            <div class="bom-mode-buttons">
                                <button class="bom-mode-btn" id="bomAddModeBtn" onclick="toggleBomAddMode()" title="Select a BOM item, then click in CL to add cutters of that type">
                                    <span class="mode-icon">+</span> Add Mode
                                </button>
                                <button class="bom-mode-btn" id="bomReplaceModeBtn" onclick="toggleBomReplaceMode()" title="Select a BOM item, then click cutters with same size to replace">
                                    <span class="mode-icon">â†”</span> Replace Mode
                                </button>
                            </div>
                            <div class="bom-selected-info" id="bomSelectedInfo" style="display:none;">
                                Selected: <strong id="bomSelectedType">-</strong> (Size: <span id="bomSelectedSize">-</span>)
                                <button class="btn btn-sm" style="background:#dc3545; padding:2px 8px;" onclick="clearBomSelection()">Clear</button>
                            </div>
                            <div style="margin-left:auto; display:flex; align-items:center; gap:10px;">
                                <button class="bom-mode-btn active" id="showDeletedToggle" onclick="toggleDeletedRows()" title="Show/hide original reference items">
                                    <span class="mode-icon">ðŸ“‹</span> Original Refs (<span id="deletedCount">0</span>)
                                </button>
                            </div>
                        </div>
                        <div id="bomMergedTable"></div>
                    </div>
                </div>

                <!-- Blades Section -->
                <div class="cl-section" id="bladesSection">
                    <div class="cl-section-header-simple">
                        <h4>Cutter Layout</h4>
                    </div>
                    <p style="margin-bottom:10px; font-size:10px; color:#666;">
                        <strong>Tips:</strong> Hover cutter for actions: <b>â†+</b> add left, <b>â§‰</b> copy/paste, <b>âœŽ</b> edit, <b>âœ•</b> delete, <b>+â†’</b> add right.
                        Row actions: <b>â§‰</b> clone row, <b>+</b> add row, <b>âœ•</b> delete row. Drag to reorder cutters, rows, or blades.
                    </p>
                    <div id="bladesEditor"></div>
                    <div style="margin-top:10px; text-align:right;">
                        <button class="btn btn-green btn-sm" onclick="addNewBlade()">+ Add New Blade</button>
                    </div>
                </div>
            </div>

            <!-- Pockets Locations Tab -->
            <div class="tab-content" id="tab-locations">
                <h3 style="margin-bottom:8px; font-size:14px;">Pockets Locations Summary</h3>
                <p style="margin-bottom:8px; font-size:10px; color:#666;">
                    <strong>Legend:</strong>
                    <span class="loc-symbol loc-C">C</span>=CONE
                    <span class="loc-symbol loc-N">N</span>=NOSE
                    <span class="loc-symbol loc-S">S</span>=SHOULDER
                    <span class="loc-symbol loc-G">G</span>=GAUGE
                    <span class="loc-symbol loc-P">P</span>=PAD
                </p>
                <div id="locationsContent"></div>
            </div>

            <div class="action-bar">
                {% if design_context %}
                <button class="btn" style="background: #1e3a5f;" onclick="createBOMFromPDF()">ðŸ“‹ Create BOM for {{ design_context.design_mat }}</button>
                {% else %}
                <!-- Standalone Mode: Show option to link to design -->
                <button class="btn" style="background: #1e3a5f;" onclick="openDesignLinkModal()">ðŸ“‹ Create BOM (Link to Design)</button>
                {% endif %}
                <button class="btn btn-green" onclick="generatePDF()">ðŸ“„ Generate PDF</button>
                <button class="btn btn-gray" onclick="exportJSON()">ðŸ’¾ Export JSON</button>
                <button class="btn btn-gray" onclick="resetApp()">ðŸ”„ New Upload</button>
                <span id="validationStatus" style="margin-left: 15px; padding: 5px 10px; border-radius: 4px; font-size: 11px; cursor: pointer;" onclick="runValidationCheck()" title="Click to re-validate"></span>
            </div>
        </div>
        
        <div id="resultMessage" class="message hidden"></div>
    </div>

    <!-- Insert Mode Indicator -->
    <div class="insert-indicator" id="insertIndicator">
        <span id="insertMessage">Click between cutters to place</span>
        <button class="cancel-btn" onclick="cancelInsertMode()">Cancel (Esc)</button>
    </div>

    <!-- Add/Edit Cutter Modal -->
    <div class="modal" id="cutterModal">
        <div class="modal-box">
            <div class="modal-header">
                <h3 id="modalTitle">Add Cutter</h3>
                <button class="modal-close" onclick="closeCutterModal()">&times;</button>
            </div>
            <input type="hidden" id="modalBladeIdx">
            <input type="hidden" id="modalRow">
            <input type="hidden" id="modalPos">
            <input type="hidden" id="modalCellIdx" value="-1">
            <input type="hidden" id="modalEditMode" value="add">
            <div class="form-row">
                <div class="form-group">
                    <label>Cutter Type</label>
                    <select id="modalCutterType" onchange="updateModalGroup()">
                        <option value="CT418" data-group="1">CT418 (Group 1)</option>
                        <option value="CT170" data-group="1">CT170 (Group 1)</option>
                        <option value="CT179T" data-group="3">CT179T (Group 3)</option>
                        <option value="CT200NL" data-group="4">CT200NL (Group 4)</option>
                        <option value="CT31" data-group="1">CT31 (Group 1)</option>
                        <option value="WC-MAT400" data-group="2">WC-MAT400 (Group 2)</option>
                    </select>
                </div>
                <div class="form-group">
                    <label>Group (BOM Index)</label>
                    <input type="number" id="modalGroup" value="1" min="1" max="20" onchange="onModalGroupChange()">
                </div>
            </div>
            <div class="form-row">
                <div class="form-group">
                    <label>Chamfer</label>
                    <select id="modalChamfer">
                        <option value="18C-60">18C-60</option>
                        <option value="U-60">U-60</option>
                        <option value="18C">18C</option>
                        <option value="DROP-IN">DROP-IN</option>
                        <option value="NA">NA</option>
                        <option value="">None</option>
                    </select>
                </div>
            </div>
            <!-- Shape editing section -->
            <div class="form-row" style="margin-top:10px;">
                <div class="form-group" style="flex:1;">
                    <label>Cutter Shape (Side View)</label>
                    <div class="shape-edit-container">
                        <div class="shape-preview" id="modalShapePreview">
                            <span class="shape-placeholder">No shape</span>
                        </div>
                        <div class="shape-actions">
                            <label class="btn btn-sm" style="background:#6c757d; cursor:pointer;">
                                Upload
                                <input type="file" id="modalShapeUpload" accept="image/*" style="display:none;" onchange="handleShapeUpload(this)">
                            </label>
                            <button class="btn btn-sm" style="background:#dc3545;" onclick="clearShapeUpload()" title="Remove shape">Clear</button>
                        </div>
                        <input type="hidden" id="modalShapeData" value="">
                    </div>
                    <small style="color:#666; font-size:10px;">Shape is linked to BOM Group. Changing it updates all cutters with this group.</small>
                </div>
            </div>
            <div style="margin-top:15px; text-align:right;">
                <button class="btn btn-gray" onclick="closeCutterModal()">Cancel</button>
                <button class="btn btn-green" id="modalSaveBtn" onclick="saveCutterEnhanced()">Add Cutter</button>
            </div>
        </div>
    </div>

    <!-- MAT Number Dialog -->
    <div class="mat-dialog hidden" id="matDialog">
        <div class="mat-dialog-box">
            <div class="mat-dialog-title">Set New MAT Identifier</div>
            <p style="font-size:11px; color:#666; margin-bottom:10px;">
                Enter a suffix for the modified file (e.g., M, M1, M2, or custom text).<br>
                Original: <strong id="matDialogOriginal"></strong>
            </p>
            <input type="text" class="mat-dialog-input" id="matDialogInput" placeholder="e.g., M1">
            <div style="margin-bottom:10px;">
                <label style="font-size:11px; display:flex; align-items:center; gap:5px;">
                    <input type="checkbox" id="matDialogAddSN"> Also set Serial Number:
                    <input type="text" id="matDialogSN" style="width:100px; padding:4px;" placeholder="SN">
                </label>
            </div>
            <div style="margin-bottom:10px; padding:8px; background:#fff3cd; border-radius:4px; border:1px solid #ffc107;">
                <label style="font-size:11px; display:flex; align-items:center; gap:5px; color:#856404;">
                    <input type="checkbox" id="matDialogNoSuffix"> Generate as correction (no suffix required)
                </label>
            </div>
            <div class="mat-dialog-buttons">
                <button class="btn btn-gray" onclick="closeMatDialog()">Cancel</button>
                <button class="btn btn-green" onclick="saveMatDialog()">Apply</button>
            </div>
        </div>
    </div>

    <!-- Split Item Dialog -->
    <div class="mat-dialog hidden" id="splitDialog">
        <div class="mat-dialog-box">
            <div class="mat-dialog-title">Quantity Changed</div>
            <p style="font-size:11px; color:#666; margin-bottom:10px;" id="splitDialogMsg"></p>
            <div class="mat-dialog-buttons">
                <button class="btn btn-gray" onclick="closeSplitDialog(false)">No, Just Reduce</button>
                <button class="btn btn-green" onclick="closeSplitDialog(true)">Yes, Add New Item</button>
            </div>
        </div>
    </div>

    <!-- Delete BOM Item Confirmation Dialog -->
    <div class="mat-dialog hidden" id="deleteBomDialog">
        <div class="mat-dialog-box" style="max-width: 400px;">
            <div class="mat-dialog-title">Delete BOM Item</div>
            <p style="font-size:12px; color:#333; margin-bottom:15px;" id="deleteBomDialogMsg"></p>
            <p style="font-size:11px; color:#666; margin-bottom:15px;">Choose how to handle cutters in the Cutter Layout:</p>
            <div class="delete-options">
                <button class="delete-option-btn placeholder-btn" onclick="confirmDeleteBom('placeholder')">
                    <span class="option-icon">?</span>
                    <span class="option-text">
                        <strong>Keep as Placeholders</strong>
                        <small>Cutters remain in CL as unassigned placeholders (red glow)</small>
                    </span>
                </button>
                <button class="delete-option-btn remove-btn" onclick="confirmDeleteBom('remove')">
                    <span class="option-icon">ðŸ—‘</span>
                    <span class="option-text">
                        <strong>Delete from CL</strong>
                        <small>Completely remove cutters from the Cutter Layout</small>
                    </span>
                </button>
            </div>
            <div class="mat-dialog-buttons" style="margin-top:15px;">
                <button class="btn btn-gray" onclick="closeDeleteBomDialog()">Cancel</button>
            </div>
        </div>
    </div>

    <!-- Validation Warning Dialog -->
    <div class="mat-dialog hidden" id="validationDialog">
        <div class="mat-dialog-box" style="max-width: 500px;">
            <div class="mat-dialog-title" style="color: #856404; background: #fff3cd; padding: 10px; margin: -15px -15px 15px -15px; border-radius: 4px 4px 0 0;">
                âš ï¸ Validation Warnings
            </div>
            <p style="font-size:12px; color:#333; margin-bottom:10px;">
                The following issues were detected in the data:
            </p>
            <div id="validationMessages" style="max-height: 200px; overflow-y: auto; margin-bottom:15px; padding: 10px; background: #f8f9fa; border-radius: 4px; font-size: 11px;">
            </div>
            <p style="font-size:11px; color:#666; margin-bottom:15px;">
                Do you want to continue generating the PDF anyway?
            </p>
            <div class="mat-dialog-buttons">
                <button class="btn btn-gray" onclick="closeValidationDialog(false)">Cancel</button>
                <button class="btn btn-green" onclick="closeValidationDialog(true)">Generate Anyway</button>
            </div>
        </div>
    </div>

    <!-- MAT Selection Table Dialog with Tabulator -->
    <div class="mat-table-dialog hidden" id="matTableDialog">
        <input type="hidden" id="matTableMode" value="bom">
        <div class="mat-table-box">
            <div class="mat-table-header">
                <div class="mat-table-header-left">
                    <div>
                        <div class="mat-table-title">Select Cutter MAT</div>
                        <div class="mat-table-subtitle" id="matTableBomInfo">Updating BOM Item #1</div>
                    </div>
                    <span class="mat-size-locked" id="matTableSizeInfo">Size: 16mm</span>
                    <button class="mat-size-unlock-btn" id="matTableUnlockBtn" onclick="toggleMatSizeLock()">ðŸ”“ Unlock</button>
                </div>
                <button class="mat-table-close-btn" onclick="closeMatTableDialog()">&times;</button>
            </div>
            <div class="mat-table-container">
                <div id="matTabulatorTable"></div>
            </div>
            <div class="mat-table-footer">
                <div class="mat-table-info">
                    <span class="mat-table-info-count" id="matTableCount">0 items</span>
                    <span class="mat-table-info-selected" id="matTableSelected">Click a row to select</span>
                    <button onclick="clearMatFilters()" style="background:#ff5252;color:white;border:none;padding:5px 12px;border-radius:15px;cursor:pointer;font-size:11px;font-weight:500;">âŸ² Clear Filters</button>
                </div>
                <div class="mat-table-buttons">
                    <button class="btn btn-gray" onclick="closeMatTableDialog()">Cancel</button>
                    <button class="btn btn-green" id="matTableApplyBtn" onclick="applyMatTableSelection()" disabled>âœ“ Apply Selected</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Design Link Modal (Standalone Mode) -->
    <div class="mat-dialog hidden" id="designLinkModal">
        <div class="mat-dialog-box" style="max-width: 700px; max-height: 80vh;">
            <div class="mat-dialog-title" style="display: flex; justify-content: space-between; align-items: center;">
                <span>ðŸ“‹ Link to Design & Create BOM</span>
                <button onclick="closeDesignLinkModal()" style="background:none;border:none;font-size:20px;cursor:pointer;color:#666;">&times;</button>
            </div>
            <p style="font-size:12px; color:#666; margin-bottom:15px;">
                Select a Design (L3/L4) to link this PDF data and create a BOM:
            </p>

            <!-- Search Box -->
            <input type="text" id="designLinkSearch" placeholder="Search by MAT, HDBS Type..."
                   style="width:100%; padding:8px 12px; border:1px solid #ccc; border-radius:4px; margin-bottom:10px; font-size:12px;"
                   oninput="filterDesignLinkTable(this.value)">

            <!-- Design Table -->
            <div style="max-height:300px; overflow-y:auto; border:1px solid #ddd; border-radius:4px;">
                <table style="width:100%; font-size:11px;">
                    <thead style="background:#f5f5f5; position:sticky; top:0;">
                        <tr>
                            <th style="padding:8px; text-align:left;">Level</th>
                            <th style="padding:8px; text-align:left;">MAT No.</th>
                            <th style="padding:8px; text-align:left;">HDBS Type</th>
                            <th style="padding:8px; text-align:left;">Size</th>
                            <th style="padding:8px; text-align:center;">Select</th>
                        </tr>
                    </thead>
                    <tbody id="designLinkTableBody">
                        <tr><td colspan="5" style="padding:20px; text-align:center; color:#999;">Loading designs...</td></tr>
                    </tbody>
                </table>
            </div>

            <!-- Or create new design option -->
            <div style="margin-top:15px; padding-top:15px; border-top:1px solid #eee;">
                <p style="font-size:11px; color:#666; margin-bottom:10px;">
                    Don't see the design you need?
                </p>
                <a href="{% url 'technology:design_create' %}?from=cutter_map"
                   style="display:inline-block; padding:8px 15px; background:#28a745; color:white; text-decoration:none; border-radius:4px; font-size:12px;">
                    + Create New Design
                </a>
            </div>

            <div class="mat-dialog-buttons" style="margin-top:15px;">
                <button class="btn btn-gray" onclick="closeDesignLinkModal()">Cancel</button>
            </div>
        </div>
    </div>

    <script>
        let currentData = null;
        let originalData = null; // Store original data for comparison/export
        let fullPageView = 'original'; // 'original' or 'modified'

        // ========== EDIT LAYOUT STATE ==========
        let editState = {
            mode: 'edit', // 'edit' or 'review'
            selectedBomIndex: null,
            newMatSuffix: '',
            newSerialNumber: '',
            splitCallback: null,
            clDrivenMode: false, // When true, CL clicks update BOM quantities
            originalSizeTotals: {}, // Tracks original total qty per size (e.g., {'16': 24, '13': 18})
            bomFolded: false, // When true, only show BOM items with same size as selected
            matIdExplicitlySet: false // Tracks if user explicitly set a new MAT ID
        };

        // Calculate original totals per size from BOM
        function calculateOriginalSizeTotals() {
            if (!originalData || !originalData.summary) return;
            editState.originalSizeTotals = {};
            originalData.summary.forEach(item => {
                const size = normalizeSize(item.size);
                if (!editState.originalSizeTotals[size]) {
                    editState.originalSizeTotals[size] = 0;
                }
                editState.originalSizeTotals[size] += item.count;
            });
            console.log('Original size totals:', editState.originalSizeTotals);
        }

        // Get current total for a size across all BOM items
        function getCurrentBomTotalForSize(size) {
            if (!currentData || !currentData.summary) return 0;
            const normalizedSize = normalizeSize(size);
            return currentData.summary
                .filter(item => normalizeSize(item.size) === normalizedSize)
                .reduce((sum, item) => sum + item.count, 0);
        }

        // Get CL count for a size
        function getCLTotalForSize(size) {
            if (!currentData || !currentData.blades) return 0;
            const normalizedSize = normalizeSize(size);
            let count = 0;
            currentData.blades.forEach(blade => {
                ['r1', 'r2', 'r3', 'r4'].forEach(rowKey => {
                    if (blade[rowKey]) {
                        Object.values(blade[rowKey]).forEach(cells => {
                            cells.forEach(cell => {
                                const cellBomItem = currentData.summary.find(b => b.index === cell.group);
                                if (cellBomItem && normalizeSize(cellBomItem.size) === normalizedSize) {
                                    count++;
                                }
                            });
                        });
                    }
                });
            });
            return count;
        }

        // ========== UNDO/REDO HISTORY ==========
        const MAX_HISTORY = 50;
        let undoStack = [];
        let redoStack = [];

        function saveToHistory() {
            if (!currentData) return;
            // Deep clone current state (including cutter_shapes for re-index)
            const snapshot = JSON.parse(JSON.stringify({
                summary: currentData.summary,
                blades: currentData.blades,
                cutter_shapes: currentData.cutter_shapes || {}
            }));
            undoStack.push(snapshot);
            if (undoStack.length > MAX_HISTORY) {
                undoStack.shift(); // Remove oldest
            }
            redoStack = []; // Clear redo stack on new action
            updateUndoRedoButtons();
            clearValidationStatus(); // Clear validation when data changes
        }

        function undoEdit() {
            if (undoStack.length === 0) return;
            // Save current state to redo stack
            const currentSnapshot = JSON.parse(JSON.stringify({
                summary: currentData.summary,
                blades: currentData.blades,
                cutter_shapes: currentData.cutter_shapes || {}
            }));
            redoStack.push(currentSnapshot);

            // Restore previous state
            const prevState = undoStack.pop();
            currentData.summary = prevState.summary;
            currentData.blades = prevState.blades;
            if (prevState.cutter_shapes) currentData.cutter_shapes = prevState.cutter_shapes;

            updateUndoRedoButtons();
            renderEditLayout();
            renderBomTable();
            renderBomMergedTable();  // Deep Edit BOM
            renderBladesEditor();     // Deep Edit CL
            renderFullPage();
            updateStats();
        }

        function redoEdit() {
            if (redoStack.length === 0) return;
            // Save current state to undo stack
            const currentSnapshot = JSON.parse(JSON.stringify({
                summary: currentData.summary,
                blades: currentData.blades,
                cutter_shapes: currentData.cutter_shapes || {}
            }));
            undoStack.push(currentSnapshot);

            // Restore next state
            const nextState = redoStack.pop();
            currentData.summary = nextState.summary;
            currentData.blades = nextState.blades;
            if (nextState.cutter_shapes) currentData.cutter_shapes = nextState.cutter_shapes;

            updateUndoRedoButtons();
            renderEditLayout();
            renderBomTable();
            renderBomMergedTable();  // Deep Edit BOM
            renderBladesEditor();     // Deep Edit CL
            renderFullPage();
            updateStats();
        }

        function updateUndoRedoButtons() {
            // Edit Layout buttons
            const undoBtn = document.querySelector('.undo-btn');
            const redoBtn = document.querySelector('.redo-btn');
            if (undoBtn) undoBtn.disabled = undoStack.length === 0;
            if (redoBtn) redoBtn.disabled = redoStack.length === 0;

            // Deep Edit buttons
            const deepUndoBtn = document.querySelector('.deep-undo-btn');
            const deepRedoBtn = document.querySelector('.deep-redo-btn');
            if (deepUndoBtn) deepUndoBtn.disabled = undoStack.length === 0;
            if (deepRedoBtn) deepRedoBtn.disabled = redoStack.length === 0;

            // Update history info
            const historyInfo = document.getElementById('deepEditHistoryInfo');
            if (historyInfo) {
                if (undoStack.length === 0 && redoStack.length === 0) {
                    historyInfo.textContent = 'No changes';
                } else {
                    historyInfo.textContent = `${undoStack.length} undo / ${redoStack.length} redo available`;
                }
            }
        }

        // Keyboard shortcuts for undo/redo
        document.addEventListener('keydown', (e) => {
            if ((e.ctrlKey || e.metaKey) && e.key === 'z' && !e.shiftKey) {
                e.preventDefault();
                undoEdit();
            } else if ((e.ctrlKey || e.metaKey) && (e.key === 'y' || (e.key === 'z' && e.shiftKey))) {
                e.preventDefault();
                redoEdit();
            }
        });

        // Color palette for BOM items
        const BOM_COLORS = ['#e53935', '#1e88e5', '#43a047', '#fb8c00', '#8e24aa', '#00acc1', '#d81b60', '#6d4c41', '#546e7a'];

        // Position symbols
        const POS_SYMBOLS = { 'CONE': 'C', 'NOSE': 'N', 'SHOULDER': 'S', 'GAUGE': 'G', 'PAD': 'P' };
        const POS_COLORS = { 'CONE': '#ef9a9a', 'NOSE': '#a5d6a7', 'SHOULDER': '#90caf9', 'GAUGE': '#fff59d', 'PAD': '#ce93d8' };

        // Real Cutter MATs Database (Halliburton cutters) with inventory quantities
        const TEST_CUTTER_MATS = [
            // 16mm cutters - 1613 size code
            { mat: '2002126', size: '1613', type: 'CT186', chamfer: 'U-60', family: 'S - Super Premium - WH', qty: 150 },
            { mat: '1291852', size: '1613', type: 'CT186R', chamfer: 'U', family: 'S - Super Premium - PLW WH', qty: 85 },
            { mat: '1291870', size: '1613', type: 'CT186', chamfer: '18-60', family: 'S - Super Premium - WH', qty: 200 },
            { mat: '2024666', size: '1613', type: 'CT186R', chamfer: 'U', family: 'S - Super Premium - PLW WH', qty: 0 },
            { mat: '1270606', size: '1613', type: 'CT200NL', chamfer: '18-30', family: 'S - Synthetic - RS PLW', qty: 120 },
            // 16mm cutters - 1608 size code
            { mat: '1193703', size: '1608', type: 'CT200', chamfer: '18-60', family: 'Premium Synthetic - RS', qty: 75 },
            { mat: '1149117', size: '1608', type: 'CT400', chamfer: '18-60', family: 'S - Super Premium - WH', qty: 45 },
            { mat: '1249128', size: '1608', type: 'CT200NL', chamfer: '18-60', family: 'S - Synthetic - RS PLW', qty: 180 },
            { mat: '1146345', size: '1608', type: 'CT418', chamfer: '18C-60', family: 'S - Super Premium - WH', qty: 95 },
            // 16mm cutters - 16 generic size code
            { mat: '1193706', size: '16', type: 'CT200', chamfer: '18-60', family: 'Premium Synthetic - RS', qty: 60 },
            { mat: '1149118', size: '16', type: 'CT400', chamfer: 'U-60', family: 'S - Super Premium - WH', qty: 35 },
            // 13mm cutters - 1313 size code
            { mat: '2008253', size: '1313', type: 'CT187', chamfer: 'U', family: 'S - Super Premium - ABS', qty: 60 },
            { mat: '2008254', size: '1313', type: 'CT186', chamfer: 'U', family: 'S - Super Premium - ABS', qty: 110 },
            { mat: '1146346', size: '1313', type: 'CT418', chamfer: '18C-60', family: 'S - Super Premium - WH', qty: 200 },
            { mat: '1249127', size: '1313', type: 'CT200NL', chamfer: '18-60', family: 'S - Synthetic - RS PLW', qty: 145 },
            { mat: '1146419', size: '1313', type: 'CT400', chamfer: '18-60', family: 'S - Super Premium - WH', qty: 0 },
            // 13mm cutters - 1308 size code
            { mat: '1291871', size: '1308', type: 'CT186', chamfer: '18-60', family: 'S - Super Premium - WH', qty: 175 },
            { mat: '1193704', size: '1308', type: 'CT200', chamfer: '18-60', family: 'Premium Synthetic - RS', qty: 90 },
            { mat: '871781', size: '1308', type: 'CT200NL', chamfer: '18C-60', family: 'S - Synthetic - RS PLW', qty: 130 },
            { mat: '2001155', size: '1308', type: 'CT179T', chamfer: 'U-60', family: 'Super Premium - WH', qty: 55 },
            // 13mm cutters - 13 generic size code
            { mat: '1224949', size: '13', type: 'CT186R', chamfer: 'U', family: 'S - Super Premium - PLW WH', qty: 70 },
            { mat: '2002127', size: '13', type: 'CT186', chamfer: 'U-60', family: 'S - Super Premium - WH', qty: 160 },
            { mat: '1155908', size: '13', type: 'CT200', chamfer: '18-60', family: 'Premium Synthetic - RS', qty: 0 },
            // 19mm cutters - 1913 size code
            { mat: '1156497', size: '1913', type: 'CT200', chamfer: '18-60', family: 'Premium Synthetic - RS', qty: 80 },
            { mat: '1270607', size: '1913', type: 'CT200NL', chamfer: '18-30', family: 'S - Synthetic - RS PLW', qty: 65 },
            { mat: '1249129', size: '1913', type: 'CT200NL', chamfer: '18-60', family: 'S - Synthetic - RS PLW', qty: 140 },
            // 19mm cutters - 1908 size code
            { mat: '1193705', size: '1908', type: 'CT200', chamfer: '18-60', family: 'Premium Synthetic - RS', qty: 50 },
            { mat: '1291872', size: '1908', type: 'CT186', chamfer: '18-60', family: 'S - Super Premium - WH', qty: 190 },
            { mat: '2002128', size: '1908', type: 'CT186', chamfer: 'U-60', family: 'S - Super Premium - WH', qty: 100 },
            { mat: '1146347', size: '1908', type: 'CT418', chamfer: '18C-60', family: 'S - Super Premium - WH', qty: 75 },
            // 12mm cutters - 1218 size code
            { mat: '1197003', size: '1218', type: 'CT187', chamfer: 'U', family: 'S - Super Premium - ABS', qty: 40 },
            { mat: '1197004', size: '1218', type: 'CT186', chamfer: 'U', family: 'S - Super Premium - ABS', qty: 85 },
            { mat: '1249126', size: '1218', type: 'CT200NL', chamfer: '18-60', family: 'S - Synthetic - RS PLW', qty: 115 },
            { mat: '1193702', size: '1218', type: 'CT200', chamfer: '18-60', family: 'Premium Synthetic - RS', qty: 95 },
            // 8mm cutters - 0808 size code
            { mat: '649901', size: '0808', type: 'WC-MAT400', chamfer: 'NA', family: 'Wear Cutter', qty: 300 },
            { mat: '649902', size: '0808', type: 'WC-MAT401', chamfer: 'NA', family: 'Wear Cutter', qty: 250 },
            // 8mm cutters - 08 generic size code
            { mat: '649903', size: '08', type: 'WC-MAT400', chamfer: 'NA', family: 'Wear Cutter', qty: 180 },
        ];

        // Normalize size codes: "1613" -> "16", "1613MM" -> "16", "16mm" -> "16", "13" -> "13", etc.
        // Format date with time: "MM/DD/YYYY H:MM:SS AM/PM"
        function formatDateWithTime(date = new Date()) {
            const month = String(date.getMonth() + 1).padStart(2, '0');
            const day = String(date.getDate()).padStart(2, '0');
            const year = date.getFullYear();

            let hours = date.getHours();
            const minutes = String(date.getMinutes()).padStart(2, '0');
            const seconds = String(date.getSeconds()).padStart(2, '0');
            const ampm = hours >= 12 ? 'PM' : 'AM';
            hours = hours % 12;
            hours = hours ? hours : 12; // 0 should be 12

            return `${month}/${day}/${year} ${hours}:${minutes}:${seconds} ${ampm}`;
        }

        function normalizeSize(size) {
            if (!size) return '';
            let s = String(size).trim();

            // Remove MM/mm suffix first (handles "1613MM", "16MM", "16mm")
            s = s.replace(/mm$/i, '');

            // If 4 digits (like 1613, 1313), take first 2
            if (/^\d{4}$/.test(s)) {
                return s.substring(0, 2);
            }
            // If 1-2 digits, return as-is
            if (/^\d{1,2}$/.test(s)) {
                return s;
            }
            // Fallback: return cleaned value
            return s;
        }

        // Blade fill order: B1, then last to second (B5, B4, B3, B2 for 5 blades)
        function getBladeOrder(bladeCount) {
            if (bladeCount <= 1) return [0];
            const order = [0]; // B1 first
            for (let i = bladeCount - 1; i >= 1; i--) {
                order.push(i);
            }
            return order;
        }

        // Cutter catalog with GROUP info
        const cutterCatalog = {
            '1146346': { size: '1313', chamfer: '18C-60', type: 'CT418', group: 1 },
            '649901': { size: '8MM', chamfer: 'NA', type: 'WC-MAT400', group: 2 },
            '2001155': { size: '1313', chamfer: 'U-60', type: 'CT179T', group: 3 },
            '871781': { size: '1313', chamfer: '18C-60', type: 'CT200NL', group: 4 },
            '1271790': { size: '1613', chamfer: '18C-60', type: 'CT170', group: 1 },
            '1146737': { size: '1613', chamfer: '18C-60', type: 'CT418', group: 1 }
        };
        
        // Type to group mapping
        const typeToGroup = {
            'CT418': 1, 'CT170': 1, 'CT31': 1,
            'WC-MAT400': 2,
            'CT179T': 3,
            'CT200NL': 4
        };
        
        // Tab switching
        document.querySelectorAll('.tab').forEach(tab => {
            tab.addEventListener('click', () => {
                document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
                document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
                tab.classList.add('active');
                document.getElementById('tab-' + tab.dataset.tab).classList.add('active');
                if (tab.dataset.tab === 'fullpage') renderFullPage();
                if (tab.dataset.tab === 'editlayout') renderEditLayout();
                if (tab.dataset.tab === 'locations') renderLocations();
            });
        });

        // ========== PANEL RESIZER ==========
        (function initPanelResizer() {
            const resizer = document.getElementById('panelResizer');
            const bomPanel = document.getElementById('editBomPanel');
            const clPanel = document.getElementById('editClPanel');
            const container = document.getElementById('editLayoutMain');

            if (!resizer || !bomPanel || !clPanel || !container) return;

            let isResizing = false;
            let startX = 0;
            let startBomWidth = 0;

            resizer.addEventListener('mousedown', (e) => {
                isResizing = true;
                startX = e.clientX;
                startBomWidth = bomPanel.offsetWidth;
                resizer.classList.add('dragging');
                document.body.style.cursor = 'col-resize';
                document.body.style.userSelect = 'none';
                e.preventDefault();
            });

            document.addEventListener('mousemove', (e) => {
                if (!isResizing) return;

                const dx = e.clientX - startX;
                let newBomWidth = startBomWidth + dx;

                // Enforce min/max constraints
                const minBomWidth = 200;
                const maxBomWidth = 600;
                const minClWidth = 300;
                const containerWidth = container.offsetWidth - resizer.offsetWidth - 8; // account for resizer and margins

                newBomWidth = Math.max(minBomWidth, Math.min(maxBomWidth, newBomWidth));

                // Ensure CL panel doesn't get too small
                if (containerWidth - newBomWidth < minClWidth) {
                    newBomWidth = containerWidth - minClWidth;
                }

                bomPanel.style.width = newBomWidth + 'px';
            });

            document.addEventListener('mouseup', () => {
                if (isResizing) {
                    isResizing = false;
                    resizer.classList.remove('dragging');
                    document.body.style.cursor = '';
                    document.body.style.userSelect = '';
                }
            });
        })();

        // Upload handlers
        const uploadArea = document.getElementById('uploadArea');
        const fileInput = document.getElementById('fileInput');
        uploadArea.addEventListener('dragover', e => { e.preventDefault(); uploadArea.style.borderColor = '#C8102E'; });
        uploadArea.addEventListener('dragleave', () => uploadArea.style.borderColor = '#ccc');
        uploadArea.addEventListener('drop', e => { e.preventDefault(); uploadArea.style.borderColor = '#ccc'; if(e.dataTransfer.files[0]) uploadFile(e.dataTransfer.files[0]); });
        fileInput.addEventListener('change', e => { if(e.target.files[0]) uploadFile(e.target.files[0]); });

        // Date Created auto-update handler - when user focuses on the field, update to current date/time
        document.getElementById('dateCreated').addEventListener('focus', function() {
            if (currentData && originalData) {
                // Only auto-update if there's data loaded
                const newDate = formatDateWithTime();
                this.value = newDate;
                currentData.header.date_created = newDate;
            }
        });
        
        // CSRF Token helper for Django
        function getCSRFToken() {
            return document.querySelector('meta[name="csrf-token"]').getAttribute('content');
        }

        function uploadFile(file) {
            const formData = new FormData();
            formData.append('file', file);
            formData.append('original_pdf', file);  // Django form expects this field name
            document.getElementById('uploadSection').classList.add('hidden');

            fetch('/cutter-map/upload/', {
                method: 'POST',
                body: formData,
                headers: {
                    'X-CSRFToken': getCSRFToken()
                }
            })
            .then(r => {
                console.log('Server response status:', r.status);
                return r.json();
            })
            .then(data => {
                console.log('Server response:', data);
                if (data.success) {
                    try {
                        console.log('Step 1: Setting currentData');
                        currentData = data.data;

                        console.log('Step 2: calculateOriginalSizeTotals');
                        calculateOriginalSizeTotals();

                        console.log('Step 3: convertToGroupFormat');
                        convertToGroupFormat();

                        // Store original index on each item for tracking after re-index
                        console.log('Step 3.5: Storing _originalIndex on summary items');
                        if (currentData.summary) {
                            currentData.summary.forEach(item => {
                                item._originalIndex = item.index;
                                console.log('Set _originalIndex:', item.index, 'for item:', item.type);
                            });
                        }

                        console.log('Step 4: Cloning to originalData (AFTER normalization)');
                        originalData = JSON.parse(JSON.stringify(currentData));

                        console.log('Step 5: Setting fullPageView');
                        fullPageView = 'original';

                        console.log('Step 6: updateClDrivenModeIndicator');
                        updateClDrivenModeIndicator();

                        console.log('Step 7: loadData');
                        loadData();

                        console.log('Step 8: Showing data section');
                        document.getElementById('dataSection').classList.add('active');

                        console.log('Upload and processing complete!');
                    } catch (err) {
                        console.error('Processing error at step:', err);
                        alert('Error processing data: ' + err.message + '\nCheck console for details.');
                        document.getElementById('uploadSection').classList.remove('hidden');
                    }
                } else {
                    alert('Error: ' + data.error);
                    document.getElementById('uploadSection').classList.remove('hidden');
                }
            })
            .catch(err => {
                console.error('Upload/fetch error:', err);
                alert('Error uploading file: ' + err.message);
                document.getElementById('uploadSection').classList.remove('hidden');
            });
        }
        
        function convertToGroupFormat() {
            // The backend already sends data in the correct format with group numbers
            // Just ensure each cell has the required properties
            // IMPORTANT: Store originalSize and originalGroup on each cell so fill works even when unassigned
            if (!currentData.blades) return;

            currentData.blades.forEach(blade => {
                ['r1', 'r2', 'r3', 'r4'].forEach(rowKey => {
                    if (blade[rowKey]) {
                        Object.keys(blade[rowKey]).forEach(pos => {
                            const cells = blade[rowKey][pos];
                            // Ensure each cell has required properties
                            cells.forEach(cell => {
                                // Use the group from PDF extraction (don't override!)
                                if (!cell.group) cell.group = 1;
                                if (!cell.chamfer) cell.chamfer = '';

                                // Store original group (BOM index) - this never changes
                                // Used for "fill original locations" feature
                                if (cell.originalGroup === undefined) {
                                    cell.originalGroup = cell.group;
                                }

                                // Store original size based on initial BOM group
                                // This allows fill to work even when cell becomes unassigned
                                if (!cell.originalSize) {
                                    const bomItem = currentData.summary.find(b => b.index === cell.group);
                                    if (bomItem) {
                                        cell.originalSize = normalizeSize(bomItem.size);
                                    }
                                }
                            });
                        });
                    }
                });
            });
        }

        function hasRowData(rowData) {
            // Check if a row has any cells
            if (!rowData) return false;
            return Object.values(rowData).some(cells => cells && cells.length > 0);
        }
        
        function loadData() {
            const d = currentData;
            document.getElementById('snNumber').value = d.header.sn_number || '0';
            document.getElementById('matNumber').value = d.header.mat_number || '';
            document.getElementById('dateCreated').value = d.header.date_created || '';
            document.getElementById('revisionLevel').value = d.header.revision_level || '';
            document.getElementById('softwareVersion').value = d.header.software_version || '';
            // Store groups in currentData
            currentData.groups = d.groups || [1,3,4];
            console.log('Extracted groups:', currentData.groups, 'Has legend:', d.has_group_legend);
            console.log('Group shapes:', d.images?.group_shapes);
            console.log('Group format:', d.group_format);

            renderBomTable();
            renderBomMergedTable();
            renderBladesEditor();
            updateStats();
            renderFullPage();
            renderValidation();
        }

        function renderValidation() {
            const validation = currentData.validation || {};
            const container = document.getElementById('validationMessages');

            if (!validation.messages || validation.messages.length === 0) {
                container.classList.add('hidden');
                return;
            }

            let html = '<strong>Validation:</strong><br>';
            validation.messages.forEach(msg => {
                const icon = msg.type === 'error' ? 'âŒ' : (msg.type === 'warning' ? 'âš ï¸' : (msg.type === 'success' ? 'âœ…' : 'â„¹ï¸'));
                const color = msg.type === 'error' ? '#dc3545' : (msg.type === 'warning' ? '#ffc107' : (msg.type === 'success' ? '#28a745' : '#17a2b8'));
                html += `<div style="color:${color}; margin:3px 0;">${icon} ${msg.message}</div>`;
            });

            html += `<div style="margin-top:5px; font-size:10px; color:#666;">BOM indices: [${(validation.bom_indices || []).join(', ')}] | CL groups: [${(validation.cl_groups || []).join(', ')}]</div>`;

            container.innerHTML = html;
            container.classList.remove('hidden');
        }
        
        // Legacy functions - kept for compatibility
        function renderBomTable() {
            renderBomMergedTable();
        }

        function updateBomCount(idx, val) {
            currentData.summary[idx].count = parseInt(val) || 0;
            renderBomMergedTable();
            updateStats();
        }

        function removeBom(idx) {
            saveToHistory(); // Save state for undo
            currentData.summary.splice(idx, 1);
            // Re-index but preserve _originalIndex
            currentData.summary.forEach((r, i) => {
                if (r._originalIndex === undefined && !r._isNewItem) {
                    r._originalIndex = r.index; // Preserve before re-indexing
                }
                r.index = i + 1;
            });
            renderBomTable();
            updateStats();
        }
        
        function renderBladesEditor() {
            const container = document.getElementById('bladesEditor');
            container.innerHTML = '';

            (currentData.blades || []).forEach((blade, bi) => {
                // Build rows HTML dynamically
                let rowsHtml = '';
                const rows = ['r1', 'r2', 'r3', 'r4'];
                const hasData = rows.map(r => hasRowData(blade[r]));

                rows.forEach((rowKey, ri) => {
                    if (hasData[ri]) {
                        rowsHtml += renderBladeRowEnhanced(blade[rowKey], bi, rowKey, rowKey.toUpperCase());
                    }
                });

                let html = `<div class="blade-block draggable-blade" data-blade-idx="${bi}"
                    draggable="true"
                    ondragstart="handleBladeDragStart(event,${bi})"
                    ondragend="handleBladeDragEnd(event)">
                    <div class="blade-toolbar">
                        <span class="blade-drag-handle" title="Drag to reorder blade">â˜°</span>
                        <strong>${blade.name}</strong>
                        <div style="margin-left:auto; display:flex; gap:5px;">
                            <button class="blade-action-btn clone-blade" onclick="cloneBlade(${bi})">â§‰ Clone</button>
                            <button class="blade-action-btn remove-blade" onclick="removeBlade(${bi})">âœ• Remove</button>
                        </div>
                    </div>
                    <div class="blade-inner">
                        <div class="blade-label">${blade.name}</div>
                        <div class="blade-rows-wrap">
                            ${rowsHtml}
                        </div>
                    </div>
                </div>`;
                container.innerHTML += html;
            });
        }

        // Enhanced blade row rendering - clean layout with position hover actions
        function renderBladeRowEnhanced(rowData, bladeIdx, rowKey, rowLabel) {
            const positionsOrder = ['CONE', 'NOSE', 'SHOULDER', 'GAUGE', 'PAD'];
            const cutterShapes = (currentData && currentData.cutter_shapes) || {};

            // Get active positions (those with cutters)
            const activePositions = positionsOrder.filter(pos => rowData && rowData[pos] && rowData[pos].length > 0);

            let html = `<div class="blade-row draggable-row" data-blade="${bladeIdx}" data-row="${rowKey}"
                draggable="true"
                ondragstart="handleRowDragStart(event,${bladeIdx},'${rowKey}')"
                ondragend="handleRowDragEnd(event)">
                <div class="row-label row-drag-handle" title="Drag to reorder row">${rowLabel}</div>
                <div class="row-content-wrap">
                    <div class="positions-wrap">`;

            positionsOrder.forEach((pos, posIdx) => {
                const cells = (rowData && rowData[pos]) || [];

                if (cells.length > 0) {
                    // Position label with hover actions
                    const currentPosIdx = activePositions.indexOf(pos);
                    const canMoveLeft = currentPosIdx > 0;
                    const canMoveRight = currentPosIdx < activePositions.length - 1;

                    html += `<div class="pos-label-wrapper" data-blade="${bladeIdx}" data-row="${rowKey}" data-pos="${pos}">
                        <div class="pos-actions">
                            <button class="pos-action-btn move-left" ${!canMoveLeft ? 'disabled' : ''} onclick="movePosLeft(${bladeIdx},'${rowKey}','${pos}')" title="Move left">â†</button>
                            <button class="pos-action-btn change-pos" onclick="togglePosDropdown(event,${bladeIdx},'${rowKey}','${pos}')" title="Change position">â–¼</button>
                            <button class="pos-action-btn delete-pos" onclick="deletePosition(${bladeIdx},'${rowKey}','${pos}')" title="Delete position">âœ•</button>
                            <button class="pos-action-btn move-right" ${!canMoveRight ? 'disabled' : ''} onclick="movePosRight(${bladeIdx},'${rowKey}','${pos}')" title="Move right">â†’</button>
                        </div>
                        <div class="pos-label" draggable="true"
                            ondragstart="handlePosDragStart(event,${bladeIdx},'${rowKey}','${pos}')"
                            ondragend="handlePosDragEnd(event)"
                            ondragover="handlePosDragOver(event)"
                            ondragleave="handlePosDragLeave(event)"
                            ondrop="handlePosDrop(event,${bladeIdx},'${rowKey}','${pos}')">${pos}</div>
                        <div class="pos-dropdown" id="pos-dropdown-${bladeIdx}-${rowKey}-${pos}"></div>
                    </div>`;

                    // Drop zone at start (hidden until insert mode)
                    html += `<div class="drop-zone" onclick="insertCutterAt(${bladeIdx},'${rowKey}','${pos}',0)"
                        ondragover="handleDragOver(event)" ondragenter="handleDragEnter(event)"
                        ondragleave="handleDragLeave(event)" ondrop="handleDrop(event)"
                        data-blade="${bladeIdx}" data-row="${rowKey}" data-pos="${pos}" data-idx="0"></div>`;

                    // Render cutters with actions
                    cells.forEach((c, ci) => {
                        // Placeholder if explicitly marked OR if group is null/undefined and no type
                        const isPlaceholder = c._isPlaceholder === true || (c.group === null || c.group === undefined) && !c.type;
                        const groupClass = isPlaceholder ? '' : `group-${c.group || 1}`;
                        const isNew = c._isNew ? ' new-cutter' : '';
                        const placeholderClass = isPlaceholder ? ' placeholder-cutter' : '';
                        const clipboardClass = cutterClipboard ? ' has-clipboard' : '';
                        const addLeftTitle = cutterClipboard ? `Paste ${cutterClipboard.type} (G${cutterClipboard.group}) to left` : 'Add new cutter to left';
                        const addRightTitle = cutterClipboard ? `Paste ${cutterClipboard.type} (G${cutterClipboard.group}) to right` : 'Add new cutter to right';
                        const addBtnClass = cutterClipboard ? ' has-clipboard' : '';

                        // Check if cutter can be replaced (same size as selected BOM)
                        const canReplace = bomMode === 'replace' && selectedBomForAdd && normalizeSize(c.size || '') === normalizeSize(selectedBomForAdd.item.size);
                        const replaceClass = canReplace ? ' replaceable' : '';

                        // Placeholder cutters always open edit modal on click
                        const clickHandler = isPlaceholder
                            ? `onclick="openEditCutterModal(${bladeIdx},'${rowKey}','${pos}',${ci})"`
                            : ((bomMode && selectedBomForAdd) ? `onclick="handleCutterModeClick(event,${bladeIdx},'${rowKey}','${pos}',${ci})"` : '');

                        html += `<div class="cutter-wrapper">
                            <div class="cutter-actions">
                                <button class="cutter-action-btn add-left${addBtnClass}" onclick="addCutterLeft(${bladeIdx},'${rowKey}','${pos}',${ci})" title="${addLeftTitle}">â†+</button>
                                <button class="cutter-action-btn clone${clipboardClass}" onclick="handleCloneClick(${bladeIdx},'${rowKey}','${pos}',${ci})" title="${cutterClipboard ? 'Clear clipboard' : 'Copy to clipboard'}" ${isPlaceholder ? 'disabled' : ''}>â§‰</button>
                                <button class="cutter-action-btn edit" onclick="openEditCutterModal(${bladeIdx},'${rowKey}','${pos}',${ci})" title="Edit">âœŽ</button>
                                <button class="cutter-action-btn delete" onclick="deleteCutter(${bladeIdx},'${rowKey}','${pos}',${ci})" title="Delete">âœ•</button>
                                <button class="cutter-action-btn add-right${addBtnClass}" onclick="addCutterRight(${bladeIdx},'${rowKey}','${pos}',${ci})" title="${addRightTitle}">+â†’</button>
                            </div>
                            <div class="cutter draggable${isNew}${placeholderClass}${replaceClass}" ${isPlaceholder ? '' : 'draggable="true"'}
                                ${isPlaceholder ? '' : `ondragstart="handleDragStart(event,${bladeIdx},'${rowKey}','${pos}',${ci})"`}
                                ondragend="handleDragEnd(event)" ${clickHandler} ${isPlaceholder ? 'title="Click to assign cutter type"' : ''}>`;

                        if (isPlaceholder) {
                            // Placeholder cutter - show ? and prompt to assign (RED glow)
                            html += `<div class="cutter-type" style="color:#dc3545;">NEW</div>
                                <div class="cutter-circle" style="background:#ffebee; border:2px dashed #dc3545; color:#dc3545;">?</div>
                                <div class="cutter-chamfer" style="color:#dc3545; font-size:7px;">click</div>`;
                        } else if (cutterShapes[c.group] && cutterShapes[c.group].data) {
                            html += `<div class="cutter-type">${c.type || ''}</div>
                                <div class="cutter-shape">
                                    <img src="${cutterShapes[c.group].data}" alt="${c.group}" class="cutter-shape-img">
                                    <span class="cutter-group-label">${c.group || ''}</span>
                                </div>
                                <div class="cutter-chamfer">${c.chamfer || ''}</div>`;
                        } else {
                            html += `<div class="cutter-type">${c.type || ''}</div>
                                <div class="cutter-circle ${groupClass}">${c.group || 1}</div>
                                <div class="cutter-chamfer">${c.chamfer || ''}</div>`;
                        }

                        html += `</div></div>`;

                        // Drop zone after each cutter (hidden until insert mode)
                        html += `<div class="drop-zone" onclick="insertCutterAt(${bladeIdx},'${rowKey}','${pos}',${ci + 1})"
                            ondragover="handleDragOver(event)" ondragenter="handleDragEnter(event)"
                            ondragleave="handleDragLeave(event)" ondrop="handleDrop(event)"
                            data-blade="${bladeIdx}" data-row="${rowKey}" data-pos="${pos}" data-idx="${ci + 1}"></div>`;
                    });
                }
            });

            // Add position button at the end
            html += `<div class="add-pos-wrapper">
                <button class="add-pos-btn" onclick="showAddPositionMenu(event,${bladeIdx},'${rowKey}')" title="Add position">+</button>
            </div>`;

            // Row actions
            const rowClipboardClass = rowClipboard ? ' has-clipboard' : '';
            const rowCloneTitle = rowClipboard ? 'Clear row clipboard' : 'Copy row to clipboard';
            const rowAddClass = rowClipboard ? ' has-clipboard' : '';
            const rowAddTitle = rowClipboard ? `Paste row (${Object.keys(rowClipboard.data).filter(k => rowClipboard.data[k]).length} positions)` : 'Add empty row';
            html += `<div class="row-actions">
                <button class="row-action-btn clone-row${rowClipboardClass}" onclick="handleRowCloneClick(${bladeIdx},'${rowKey}')" title="${rowCloneTitle}">â§‰</button>
                <button class="row-action-btn add-row${rowAddClass}" onclick="addRowToBlade(${bladeIdx})" title="${rowAddTitle}">+</button>
                <button class="row-action-btn delete" onclick="deleteRow(${bladeIdx},'${rowKey}')" title="Delete Row">âœ•</button>
            </div>`;

            html += `</div></div></div>`;
            return html;
        }

        // Simple blade row rendering for Full Page preview (non-editable)
        function renderBladeRow(rowData, bladeIdx, rowKey, rowLabel, editable = false) {
            let html = `<div class="blade-row">
                <div class="row-label">${rowLabel}</div>
                <div class="positions-wrap">`;

            const positionsOrder = ['CONE', 'NOSE', 'SHOULDER', 'GAUGE', 'PAD'];
            const cutterShapes = (currentData && currentData.cutter_shapes) || {};

            positionsOrder.forEach(pos => {
                const cells = (rowData && rowData[pos]) || [];
                if (cells.length > 0) {
                    html += `<div class="pos-label">${pos}</div>`;

                    cells.forEach((c, ci) => {
                        const groupClass = `group-${c.group || 1}`;

                        if (cutterShapes[c.group] && cutterShapes[c.group].data) {
                            html += `<div class="cutter">
                                <div class="cutter-type">${c.type || ''}</div>
                                <div class="cutter-shape">
                                    <img src="${cutterShapes[c.group].data}" alt="${c.group}" class="cutter-shape-img">
                                    <span class="cutter-group-label">${c.group || ''}</span>
                                </div>
                                <div class="cutter-chamfer">${c.chamfer || ''}</div>
                            </div>`;
                        } else {
                            html += `<div class="cutter">
                                <div class="cutter-type">${c.type || ''}</div>
                                <div class="cutter-circle ${groupClass}">${c.group || 1}</div>
                                <div class="cutter-chamfer">${c.chamfer || ''}</div>
                            </div>`;
                        }
                    });
                }
            });

            html += `</div></div>`;
            return html;
        }

        function addPosition(bladeIdx, rowKey, pos) {
            if (!pos) return;
            if (!currentData.blades[bladeIdx][rowKey]) currentData.blades[bladeIdx][rowKey] = {};
            if (!currentData.blades[bladeIdx][rowKey][pos]) currentData.blades[bladeIdx][rowKey][pos] = [];

            // Add one cutter with default values
            currentData.blades[bladeIdx][rowKey][pos].push({
                type: '',
                group: null,
                chamfer: '',
                _isPlaceholder: true
            });

            renderBladesEditor();
            updateStats();
        }

        function showAddCutterMenu(event, bladeIdx, rowKey) {
            event.stopPropagation();
            const positions = ['CONE', 'NOSE', 'SHOULDER', 'GAUGE', 'PAD'];
            const pos = prompt('Add cutter to position:\n' + positions.join(', '));
            if (pos && positions.includes(pos.toUpperCase())) {
                openCutterModal(bladeIdx, rowKey, pos.toUpperCase());
            }
        }
        
        function updateModalGroup() {
            const sel = document.getElementById('modalCutterType');
            const type = sel.value;
            document.getElementById('modalGroup').value = typeToGroup[type] || 1;
        }
        
        function openCutterModal(bladeIdx, rowKey, pos) {
            document.getElementById('modalTitle').textContent = 'Add Cutter';
            document.getElementById('modalSaveBtn').textContent = 'Add Cutter';
            document.getElementById('modalBladeIdx').value = bladeIdx;
            document.getElementById('modalRow').value = rowKey;
            document.getElementById('modalPos').value = pos;
            document.getElementById('modalCellIdx').value = -1;
            document.getElementById('modalEditMode').value = 'add';
            // Use selected cutter from toolbar
            document.getElementById('modalCutterType').value = selectedCutter.type;
            document.getElementById('modalGroup').value = selectedCutter.group;
            document.getElementById('modalChamfer').value = selectedCutter.chamfer;
            // Reset and load shape preview for selected group
            document.getElementById('modalShapeData').value = '';
            updateModalShapePreview(selectedCutter.group);
            document.getElementById('cutterModal').classList.add('active');
        }

        function closeCutterModal() {
            document.getElementById('cutterModal').classList.remove('active');
            // Clear shape upload input
            document.getElementById('modalShapeUpload').value = '';
        }

        // Update shape preview based on group number
        function updateModalShapePreview(groupNum) {
            const preview = document.getElementById('modalShapePreview');
            const cutterShapes = (currentData && currentData.cutter_shapes) || {};
            const shape = cutterShapes[groupNum];

            if (shape && shape.data) {
                preview.innerHTML = `<img src="${shape.data}" alt="Shape">`;
            } else {
                preview.innerHTML = '<span class="shape-placeholder">No shape</span>';
            }
        }

        // Handle shape file upload
        function handleShapeUpload(input) {
            if (!input.files || !input.files[0]) return;

            const file = input.files[0];
            const reader = new FileReader();

            reader.onload = function(e) {
                const dataUrl = e.target.result;
                document.getElementById('modalShapeData').value = dataUrl;
                document.getElementById('modalShapePreview').innerHTML = `<img src="${dataUrl}" alt="Shape">`;
            };

            reader.readAsDataURL(file);
        }

        // Clear uploaded shape
        function clearShapeUpload() {
            document.getElementById('modalShapeUpload').value = '';
            document.getElementById('modalShapeData').value = '';
            const groupNum = parseInt(document.getElementById('modalGroup').value) || 1;
            // Show existing shape for group if any, otherwise show placeholder
            updateModalShapePreview(groupNum);
        }

        // Handle group number change - update shape preview
        function onModalGroupChange() {
            // Clear any uploaded shape since group changed
            document.getElementById('modalShapeUpload').value = '';
            document.getElementById('modalShapeData').value = '';
            // Show shape for new group
            const groupNum = parseInt(document.getElementById('modalGroup').value) || 1;
            updateModalShapePreview(groupNum);
        }

        // Legacy saveCutter - redirects to enhanced version
        function saveCutter() {
            saveCutterEnhanced();
        }

        // Legacy editCutter - now opens the modal for editing
        function editCutter(bladeIdx, rowKey, pos, cellIdx) {
            openEditCutterModal(bladeIdx, rowKey, pos, cellIdx);
        }

        // Old editCutter functionality (prompt-based) - kept for reference
        function editCutterPrompt(bladeIdx, rowKey, pos, cellIdx) {
            const cell = currentData.blades[bladeIdx][rowKey][pos][cellIdx];
            const action = prompt(`Cutter: ${cell.type} (Group: ${cell.group})\nType "delete" to remove, or enter new group number:`, cell.group);
            if (action === null) return;
            saveToHistory(); // Save state for undo
            if (action.toLowerCase() === 'delete') {
                currentData.blades[bladeIdx][rowKey][pos].splice(cellIdx, 1);
                if (currentData.blades[bladeIdx][rowKey][pos].length === 0) {
                    delete currentData.blades[bladeIdx][rowKey][pos];
                }
            } else {
                const g = parseInt(action);
                if (!isNaN(g) && g >= 1 && g <= 4) cell.group = g;
            }
            renderBladesEditor();
            updateStats();
        }
        
        function addNewBlade() {
            saveToHistory(); // Save state for undo
            if (!currentData.blades) currentData.blades = [];
            const name = 'B' + (currentData.blades.length + 1);
            // Only add R1 initially - user can add R2/R3/R4 as needed
            currentData.blades.push({
                name: name,
                r1: { 'CONE': [{ type: '', group: null, chamfer: '', _isPlaceholder: true }] },
                r2: {},
                r3: {},
                r4: {}
            });
            renderBladesEditor();
            updateStats();
        }

        function removeBlade(idx) {
            saveToHistory(); // Save state for undo
            currentData.blades.splice(idx, 1);
            renderBladesEditor();
            updateStats();
        }

        // ========== ENHANCED BLADE EDITOR FUNCTIONS ==========

        // Current cutter selection (used when adding new cutters)
        let selectedCutter = { type: 'CT418', group: 1, chamfer: '18C-60' };

        // Clipboard for copied cutter
        let cutterClipboard = null;

        // Clipboard for copied row
        let rowClipboard = null;

        // Handle row clone button click - toggle copy/clear (does NOT paste)
        function handleRowCloneClick(bladeIdx, rowKey) {
            if (rowClipboard) {
                // Already have clipboard - clear it
                rowClipboard = null;
                renderBladesEditor();
                showMessage('Row clipboard cleared', 'info');
            } else {
                // Copy this row to clipboard
                const rowData = currentData.blades[bladeIdx][rowKey];
                rowClipboard = {
                    data: JSON.parse(JSON.stringify(rowData)), // Deep copy
                    sourceBladeIdx: bladeIdx,
                    sourceRowKey: rowKey
                };
                renderBladesEditor();
                const posCount = Object.keys(rowData).filter(k => rowData[k] && rowData[k].length > 0).length;
                showMessage(`Copied row ${rowKey.toUpperCase()} (${posCount} positions)`, 'info');
            }
        }

        // Handle clone button click - toggle copy/clear (does NOT paste)
        function handleCloneClick(bladeIdx, rowKey, pos, cellIdx) {
            if (cutterClipboard) {
                // Already have clipboard - clear it
                cutterClipboard = null;
                renderBladesEditor();
                showMessage('Clipboard cleared', 'info');
            } else {
                // Copy this cutter to clipboard
                const cell = currentData.blades[bladeIdx][rowKey][pos][cellIdx];
                cutterClipboard = { ...cell };
                delete cutterClipboard._isNew;
                renderBladesEditor();
                showMessage(`Copied: ${cutterClipboard.type} (Group ${cutterClipboard.group})`, 'info');
            }
        }

        // Paste cutter from clipboard at position
        function pasteCutterAt(bladeIdx, rowKey, pos, insertIdx) {
            if (!cutterClipboard) return false;

            if (!currentData.blades[bladeIdx][rowKey]) {
                currentData.blades[bladeIdx][rowKey] = {};
            }
            if (!currentData.blades[bladeIdx][rowKey][pos]) {
                currentData.blades[bladeIdx][rowKey][pos] = [];
            }

            const newCutter = { ...cutterClipboard, _isNew: true };
            currentData.blades[bladeIdx][rowKey][pos].splice(insertIdx, 0, newCutter);

            refreshEditor();
            setTimeout(clearNewCutterFlags, 1600);
            return true;
        }

        // Add cutter to the left of current position
        function addCutterLeft(bladeIdx, rowKey, pos, cellIdx) {
            if (cutterClipboard) {
                pasteCutterAt(bladeIdx, rowKey, pos, cellIdx);
            } else if (bomMode === 'add' && selectedBomForAdd) {
                // Add selected BOM item directly without dialog
                addSelectedBomCutterAt(bladeIdx, rowKey, pos, cellIdx);
            } else {
                openAddNewCutterDialog(bladeIdx, rowKey, pos, cellIdx);
            }
        }

        // Add cutter to the right of current position
        function addCutterRight(bladeIdx, rowKey, pos, cellIdx) {
            if (cutterClipboard) {
                pasteCutterAt(bladeIdx, rowKey, pos, cellIdx + 1);
            } else if (bomMode === 'add' && selectedBomForAdd) {
                // Add selected BOM item directly without dialog
                addSelectedBomCutterAt(bladeIdx, rowKey, pos, cellIdx + 1);
            } else {
                openAddNewCutterDialog(bladeIdx, rowKey, pos, cellIdx + 1);
            }
        }

        // Add selected BOM cutter at specific position
        function addSelectedBomCutterAt(bladeIdx, rowKey, pos, insertIdx) {
            if (!selectedBomForAdd) return;

            saveToHistory();
            const selectedItem = selectedBomForAdd.item;

            const newCutter = {
                type: selectedItem.type,
                group: selectedItem.index,
                chamfer: selectedItem.chamfer,
                size: selectedItem.size,
                _isNew: true
            };

            if (!currentData.blades[bladeIdx][rowKey]) currentData.blades[bladeIdx][rowKey] = {};
            if (!currentData.blades[bladeIdx][rowKey][pos]) currentData.blades[bladeIdx][rowKey][pos] = [];

            currentData.blades[bladeIdx][rowKey][pos].splice(insertIdx, 0, newCutter);
            selectedItem.count = (parseInt(selectedItem.count) || 0) + 1;

            refreshEditor();
            setTimeout(clearNewCutterFlags, 1600);
            showMessage(`Added ${selectedItem.type} at position ${insertIdx + 1}`, 'success');
        }

        // Add cutter to row (for empty rows or row add button)
        function addCutterToRow(bladeIdx, rowKey) {
            const row = currentData.blades[bladeIdx][rowKey] || {};
            const positions = ['CONE', 'NOSE', 'SHOULDER', 'GAUGE', 'PAD'];

            // Find first position with cutters, or default to CONE
            let pos = 'CONE';
            for (const p of positions) {
                if (row[p] && row[p].length > 0) {
                    pos = p;
                    break;
                }
            }

            if (cutterClipboard) {
                // Paste at end of first position
                const insertIdx = (row[pos] || []).length;
                pasteCutterAt(bladeIdx, rowKey, pos, insertIdx);
            } else {
                // Open dialog to select position and cutter
                openAddNewCutterDialog(bladeIdx, rowKey, pos, (row[pos] || []).length);
            }
        }

        // Open "Add New Item" style dialog for adding cutter
        function openAddNewCutterDialog(bladeIdx, rowKey, pos, insertIdx) {
            // Store context for when dialog saves
            window.addCutterContext = { bladeIdx, rowKey, pos, insertIdx };

            // Set mode to cutter
            document.getElementById('matTableMode').value = 'cutter';

            // Setup MAT table state
            matTableState.mode = 'add';
            matTableState.bomIdx = null;
            matTableState.lockedSize = null;
            matTableState.sizeLocked = false;
            matTableState.selectedMat = null;

            // Update dialog title and subtitle
            const titleEl = document.querySelector('.mat-table-title');
            if (titleEl) titleEl.textContent = 'Select Cutter to Add';
            document.getElementById('matTableBomInfo').textContent = `Adding cutter to ${currentData.blades[bladeIdx].name} ${rowKey.toUpperCase()} at ${pos}`;

            // Update size info display
            document.getElementById('matTableSizeInfo').textContent = `Size: ALL (select any)`;
            document.getElementById('matTableSizeInfo').style.background = '#e8f5e9';
            document.getElementById('matTableSizeInfo').style.color = '#2e7d32';
            document.getElementById('matTableUnlockBtn').textContent = 'Lock Size';

            // Disable apply button until selection
            document.getElementById('matTableApplyBtn').disabled = true;
            document.getElementById('matTableSelected').textContent = 'Click a row to select';

            // Show ALL cutters (no size filter)
            const tableData = TEST_CUTTER_MATS;

            // Initialize or update Tabulator
            if (matTableState.tabulator) {
                matTableState.tabulator.destroy();
            }

            matTableState.tabulator = new Tabulator("#matTabulatorTable", {
                data: tableData,
                height: "380px",
                layout: "fitColumns",
                selectable: 1,
                selectableRangeMode: "click",
                placeholder: "<div style='padding:30px;color:#999;'>No matching cutters found</div>",
                initialSort: [{ column: "type", dir: "asc" }],
                columns: getMatTableColumns()
            });

            // Handle row click
            matTableState.tabulator.on("rowClick", function(e, row) {
                matTableState.tabulator.deselectRow();
                row.select();

                const selected = row.getData();
                matTableState.selectedMat = selected;

                let stockInfo = selected.qty > 0 ? `(${selected.qty} in stock)` : 'âš ï¸ OUT OF STOCK';
                document.getElementById('matTableSelected').textContent =
                    `Selected: ${selected.mat} - ${selected.type} (${selected.size}) ${stockInfo}`;

                const applyBtn = document.getElementById('matTableApplyBtn');
                applyBtn.disabled = false;
                applyBtn.style.background = '#4caf50';
                applyBtn.style.cursor = 'pointer';
                applyBtn.style.opacity = '1';
            });

            matTableState.tabulator.on("dataFiltered", function(filters, rows) {
                document.getElementById('matTableCount').textContent = `${rows.length} items`;

                if (matTableState.selectedMat) {
                    const stillVisible = rows.some(r => r.getData().mat === matTableState.selectedMat.mat);
                    if (!stillVisible) {
                        matTableState.selectedMat = null;
                        document.getElementById('matTableSelected').textContent = 'Click a row to select';
                        document.getElementById('matTableApplyBtn').disabled = true;
                        document.getElementById('matTableApplyBtn').style.background = '#9e9e9e';
                    }
                }
            });

            // Show dialog
            document.getElementById('matTableDialog').classList.remove('hidden');
            document.getElementById('matTableCount').textContent = `${tableData.length} items`;
        }

        // Clone entire row
        function cloneRow(bladeIdx, rowKey) {
            const blade = currentData.blades[bladeIdx];
            const sourceRow = blade[rowKey];
            if (!sourceRow) return;

            // Find next available row
            const rows = ['r1', 'r2', 'r3', 'r4'];
            const currentIdx = rows.indexOf(rowKey);
            let targetRow = null;

            // Look for empty row after current
            for (let i = currentIdx + 1; i < rows.length; i++) {
                if (!hasRowData(blade[rows[i]])) {
                    targetRow = rows[i];
                    break;
                }
            }

            if (!targetRow) {
                showMessage('No empty row available to clone into', 'warning');
                return;
            }

            // Deep clone the row
            blade[targetRow] = JSON.parse(JSON.stringify(sourceRow));

            // Mark all cutters as new for glow effect
            Object.values(blade[targetRow]).forEach(cells => {
                cells.forEach(cell => cell._isNew = true);
            });

            refreshEditor();
            setTimeout(clearNewCutterFlags, 1600);
            showMessage(`Cloned ${rowKey.toUpperCase()} to ${targetRow.toUpperCase()}`, 'success');
        }

        // Clone entire blade
        function cloneBlade(bladeIdx) {
            const sourceBlade = currentData.blades[bladeIdx];
            const newBlade = JSON.parse(JSON.stringify(sourceBlade));

            // Update name
            newBlade.name = 'B' + (currentData.blades.length + 1);

            // Mark all cutters as new for glow effect
            ['r1', 'r2', 'r3', 'r4'].forEach(rowKey => {
                if (newBlade[rowKey]) {
                    Object.values(newBlade[rowKey]).forEach(cells => {
                        cells.forEach(cell => cell._isNew = true);
                    });
                }
            });

            currentData.blades.push(newBlade);
            refreshEditor();
            setTimeout(clearNewCutterFlags, 1600);
            showMessage(`Cloned ${sourceBlade.name} as ${newBlade.name}`, 'success');
        }

        // Show temporary message
        function showMessage(text, type = 'info') {
            const colors = { info: '#17a2b8', success: '#28a745', warning: '#ffc107', error: '#dc3545' };
            const indicator = document.getElementById('insertIndicator');
            indicator.innerHTML = `<span style="color: ${colors[type]}">${text}</span>`;
            indicator.classList.add('active');
            setTimeout(() => indicator.classList.remove('active'), 2000);
        }

                // Toggle foldable section
        function toggleSection(section) {
            const sectionEl = document.getElementById(section + 'Section');
            if (sectionEl) {
                sectionEl.classList.toggle('folded');
            }
        }

        // BOM selection state
        let selectedBomForAdd = null; // { idx, item } for add/replace mode
        let bomMode = null; // null, 'add', or 'replace'
        let showDeletedRows = true; // Show/hide deleted BOM rows

        // Render merged BOM table (combines BOM Table and BOM Comparison)
        function renderBomMergedTable() {
            const container = document.getElementById('bomMergedTable');
            if (!container) return;

            const summary = currentData.summary || [];
            const clCounts = countCuttersInCL();
            const cutterShapes = currentData.cutter_shapes || {};

            // Build map of original items by index for lookup (use _originalIndex which tracks original PDF index)
            const originalByIndex = {};
            if (originalData && originalData.summary) {
                originalData.summary.forEach(item => {
                    const idx = item._originalIndex !== undefined ? item._originalIndex : item.index;
                    // Store with both number and string keys for safe lookup
                    originalByIndex[idx] = item;
                    originalByIndex[String(idx)] = item;
                });
            }

            // Track which original indices are still in current summary (use _originalIndex for re-indexed items)
            // Use string keys for consistent Set comparison
            // Skip new items (_isNewItem) - they don't map to any original
            const currentOriginalIndices = new Set(summary
                .filter(s => !s._isNewItem)
                .map(s => {
                    const idx = s._originalIndex !== undefined ? s._originalIndex : s.index;
                    return String(idx);
                }));

            // Build map of current items by their original index
            // Skip new items - they don't correspond to any original item
            const currentByOrigIdx = {};
            summary.forEach(s => {
                if (s._isNewItem) return; // New items don't map to original indices
                const origIdx = String(s._originalIndex !== undefined ? s._originalIndex : s.index);
                currentByOrigIdx[origIdx] = s;
            });

            // Find original items that are either:
            // 1. Deleted (no longer in current)
            // 2. Re-indexed (current index differs from original index)
            const deletedOrReindexed = [];
            if (originalData && originalData.summary) {
                originalData.summary.forEach(origItem => {
                    const origIdx = String(origItem._originalIndex !== undefined ? origItem._originalIndex : origItem.index);
                    const currentItem = currentByOrigIdx[origIdx];

                    if (!currentItem) {
                        // Truly deleted
                        deletedOrReindexed.push({ ...origItem, _status: 'deleted' });
                    } else if (currentItem.index !== origItem.index) {
                        // Re-indexed (original index shown for reference)
                        deletedOrReindexed.push({ ...origItem, _status: 'reindexed', _newIndex: currentItem.index });
                    }
                });
            }

            // Use deletedOrReindexed as our "deleted" section (includes both deleted and reindexed originals)
            const deletedOriginals = deletedOrReindexed;

            if (summary.length === 0 && deletedOriginals.length === 0) {
                container.innerHTML = '<p style="color:#666; font-size:11px;">No BOM items. Click "+ Add New Item" to add cutters.</p>';
                return;
            }

            let html = `<table class="bom-merged-table">
                <thead>
                    <tr>
                        <th style="width:25px;"></th>
                        <th>#</th>
                        <th>Shape</th>
                        <th>Type</th>
                        <th>Size</th>
                        <th>Chamfer</th>
                        <th>Mat #</th>
                        <th>Family #</th>
                        <th>Orig Qty</th>
                        <th>BOM Qty</th>
                        <th>CL Count</th>
                        <th>Diff</th>
                        <th>Actions</th>
                    </tr>
                </thead>
                <tbody>`;

            // Render current items
            summary.forEach((row, idx) => {
                const bomQty = parseInt(row.count) || 0;
                const clCount = clCounts[row.index] || 0;
                const diff = clCount - bomQty;
                let diffClass = 'count-match';
                let diffText = '=';
                if (diff > 0) {
                    diffClass = 'count-more';
                    diffText = '+' + diff;
                } else if (diff < 0) {
                    diffClass = 'count-less';
                    diffText = diff.toString();
                }

                // Get original quantity - use _originalIndex to track after re-index
                // Skip lookup for newly added items (not from original PDF)
                let origQty = '-';
                if (row._isNewItem) {
                    origQty = 'NEW';
                } else {
                    const lookupIndex = row._originalIndex !== undefined ? row._originalIndex : row.index;
                    // Try both number and string keys for lookup
                    const origItem = originalByIndex[lookupIndex] || originalByIndex[String(lookupIndex)] || originalByIndex[parseInt(lookupIndex)];
                    origQty = origItem ? (parseInt(origItem.count) || 0) : '-';
                }

                const isSelected = selectedBomForAdd && selectedBomForAdd.idx === idx;
                const selectedClass = isSelected ? ' bom-selected' : '';

                const shape = cutterShapes[row.index];
                const shapeHtml = shape && shape.data
                    ? `<img src="${shape.data}" class="bom-shape-preview" alt="Shape">`
                    : '<span class="bom-shape-empty">-</span>';

                html += `<tr class="bom-row${selectedClass}" data-bom-idx="${idx}" draggable="true"
                    ondragstart="handleBomDragStart(event, ${idx})"
                    ondragend="handleBomDragEnd(event)"
                    ondragover="handleBomDragOver(event)"
                    ondrop="handleBomDrop(event, ${idx})">
                    <td><span class="bom-drag-handle" title="Drag to reorder">â˜°</span></td>
                    <td><strong>${row.index}</strong></td>
                    <td class="bom-shape-cell">
                        ${shapeHtml}
                        <label class="bom-shape-upload" title="Upload shape">
                            <input type="file" accept="image/*" style="display:none;" onchange="uploadBomShape(${row.index}, this)">
                            ðŸ“·
                        </label>
                    </td>
                    <td>${row.type || ''}</td>
                    <td>${row.size || ''}</td>
                    <td>${row.chamfer || ''}</td>
                    <td>${row.mat_number || ''}</td>
                    <td>${row.family_number || ''}</td>
                    <td style="color:#666;">${origQty}</td>
                    <td>
                        <input type="number" value="${bomQty}" min="0" style="width:50px; text-align:center;"
                            onchange="updateBomQtyFromMerged(${idx}, this.value)">
                    </td>
                    <td>${clCount}</td>
                    <td class="${diffClass}">${diffText}</td>
                    <td class="bom-actions">
                        <button class="bom-action-btn select" onclick="selectBomForMode(${idx})" title="Select for Add/Replace">âœ“</button>
                        <button class="bom-action-btn edit" onclick="openMatTableDialog(${idx})" title="Change MAT">âœŽ</button>
                        <button class="bom-action-btn delete" onclick="removeBomItemFromMerged(${idx})" title="Remove">âœ•</button>
                    </td>
                </tr>`;
            });

            html += '</tbody>';

            // Render deleted/re-indexed original items as inactive rows (in separate tbody for folding)
            if (deletedOriginals.length > 0) {
                const deletedDisplay = showDeletedRows ? '' : 'display:none;';
                html += `<tbody id="deletedRowsBody" style="${deletedDisplay}">`;
                deletedOriginals.forEach(origItem => {
                    const origQty = parseInt(origItem.count) || 0;
                    const origShapes = originalData.cutter_shapes || {};
                    const shape = origShapes[origItem.index];
                    const shapeHtml = shape && shape.data
                        ? `<img src="${shape.data}" class="bom-shape-preview" alt="Shape" style="opacity:0.5;">`
                        : '<span class="bom-shape-empty">-</span>';

                    const isDeleted = origItem._status === 'deleted';
                    const isReindexed = origItem._status === 'reindexed';

                    // Different styling for deleted vs re-indexed
                    const rowStyle = isDeleted
                        ? 'opacity:0.5; background:#ffebee; text-decoration:line-through;'  // Red-ish for deleted
                        : 'opacity:0.7; background:#e3f2fd;';  // Blue-ish for re-indexed (reference)

                    const indexDisplay = isReindexed
                        ? `<strong style="color:#1976d2;">${origItem.index}</strong> <span style="color:#999; font-size:9px;">â†’ ${origItem._newIndex}</span>`
                        : `<strong style="color:#999;">${origItem.index}</strong>`;

                    const actionBtn = isDeleted
                        ? `<button class="bom-action-btn" style="background:#28a745;" onclick="restoreDeletedBomItem(${origItem.index})" title="Restore">â†©</button>`
                        : `<span style="color:#1976d2; font-size:9px;">ref</span>`;  // Just a reference indicator

                    html += `<tr class="bom-row bom-${origItem._status}" style="${rowStyle}">
                        <td></td>
                        <td>${indexDisplay}</td>
                        <td class="bom-shape-cell">${shapeHtml}</td>
                        <td style="color:#666;">${origItem.type || ''}</td>
                        <td style="color:#666;">${origItem.size || ''}</td>
                        <td style="color:#666;">${origItem.chamfer || ''}</td>
                        <td style="color:#666;">${origItem.mat_number || ''}</td>
                        <td style="color:#666;">${origItem.family_number || ''}</td>
                        <td style="color:#666;">${origQty}</td>
                        <td style="color:#999;">-</td>
                        <td style="color:#999;">-</td>
                        <td style="color:#999;">-</td>
                        <td class="bom-actions">${actionBtn}</td>
                    </tr>`;
                });
                html += '</tbody>';
            }

            html += '</table>';
            container.innerHTML = html;

            // Update deleted count in toggle label
            const deletedCountEl = document.getElementById('deletedCount');
            if (deletedCountEl) {
                deletedCountEl.textContent = deletedOriginals.length;
            }

            // Update toggle button state
            const toggle = document.getElementById('showDeletedToggle');
            if (toggle) {
                if (showDeletedRows) {
                    toggle.classList.add('active');
                } else {
                    toggle.classList.remove('active');
                }
            }

            // Update toolbar state
            updateBomToolbarState();
        }

        // Toggle deleted rows visibility
        function toggleDeletedRows() {
            showDeletedRows = !showDeletedRows;
            const tbody = document.getElementById('deletedRowsBody');
            if (tbody) {
                tbody.style.display = showDeletedRows ? '' : 'none';
            }
            // Update button active state
            const btn = document.getElementById('showDeletedToggle');
            if (btn) {
                if (showDeletedRows) {
                    btn.classList.add('active');
                } else {
                    btn.classList.remove('active');
                }
            }
        }

        // BOM drag state
        let bomDragIdx = null;

        function handleBomDragStart(e, idx) {
            bomDragIdx = idx;
            e.target.classList.add('bom-dragging');
            e.dataTransfer.effectAllowed = 'move';
        }

        function handleBomDragEnd(e) {
            e.target.classList.remove('bom-dragging');
            document.querySelectorAll('.bom-drag-over').forEach(el => el.classList.remove('bom-drag-over'));
            bomDragIdx = null;
        }

        function handleBomDragOver(e) {
            e.preventDefault();
            const row = e.target.closest('.bom-row');
            if (row) {
                document.querySelectorAll('.bom-drag-over').forEach(el => el.classList.remove('bom-drag-over'));
                row.classList.add('bom-drag-over');
            }
        }

        function handleBomDrop(e, targetIdx) {
            e.preventDefault();
            if (bomDragIdx === null || bomDragIdx === targetIdx) return;

            saveToHistory();

            // Get the items
            const summary = currentData.summary;
            const [movedItem] = summary.splice(bomDragIdx, 1);
            summary.splice(targetIdx, 0, movedItem);

            // Get old to new index mapping
            const oldIndices = summary.map(s => s.index);

            // Reindex all BOM items (preserve _originalIndex)
            summary.forEach((item, i) => {
                if (item._originalIndex === undefined && !item._isNewItem) {
                    item._originalIndex = item.index; // Preserve before re-indexing
                }
                item.index = i + 1;
            });

            // Update CL references - map old group numbers to new
            const indexMap = {};
            oldIndices.forEach((oldIdx, newPos) => {
                indexMap[oldIdx] = newPos + 1;
            });

            updateClGroupReferences(indexMap);

            refreshEditor();
            showMessage('BOM order updated', 'success');
        }

        // Update CL group references when BOM indices change
        function updateClGroupReferences(indexMap) {
            (currentData.blades || []).forEach(blade => {
                ['r1', 'r2', 'r3', 'r4'].forEach(rowKey => {
                    if (blade[rowKey]) {
                        Object.values(blade[rowKey]).forEach(cells => {
                            cells.forEach(cell => {
                                if (cell.group !== null && cell.group !== undefined) {
                                    // Try both number and string keys for lookup
                                    const newGroup = indexMap[cell.group] !== undefined
                                        ? indexMap[cell.group]
                                        : (indexMap[String(cell.group)] !== undefined
                                            ? indexMap[String(cell.group)]
                                            : (indexMap[parseInt(cell.group)] !== undefined
                                                ? indexMap[parseInt(cell.group)]
                                                : null));
                                    if (newGroup !== null) {
                                        cell.group = newGroup;
                                    }
                                }
                            });
                        });
                    }
                });
            });
        }

        // Re-index BOM to start from 1
        function reindexBom() {
            if (!currentData.summary || currentData.summary.length === 0) return;

            const firstIndex = currentData.summary[0].index;
            if (firstIndex === 1) {
                showMessage('BOM already starts from index 1', 'info');
                return;
            }

            if (!confirm(`Re-index BOM from ${firstIndex} to start from 1?\n\nThis will update all CL references and shapes.`)) return;

            saveToHistory();

            // Create index mapping and preserve _originalIndex
            const indexMap = {};
            currentData.summary.forEach((item, i) => {
                const oldIndex = item.index;
                const newIndex = i + 1;

                // Store mapping with both number and string keys for safe lookup
                indexMap[oldIndex] = newIndex;
                indexMap[String(oldIndex)] = newIndex;

                // Preserve _originalIndex if not already set (first re-index)
                // This tracks back to the original PDF's index
                if (item._originalIndex === undefined) {
                    item._originalIndex = oldIndex;
                }
                // Note: If _originalIndex is already set, keep it (tracks original PDF index)

                item.index = newIndex;
            });

            // Update CL references
            updateClGroupReferences(indexMap);

            // Update cutter_shapes keys to match new indices
            if (currentData.cutter_shapes) {
                const oldShapes = currentData.cutter_shapes;
                const newShapes = {};
                Object.keys(indexMap).forEach(oldIdx => {
                    const newIdx = indexMap[oldIdx];
                    if (oldShapes[oldIdx]) {
                        newShapes[newIdx] = oldShapes[oldIdx];
                    }
                    // Also check string keys
                    if (oldShapes[String(oldIdx)]) {
                        newShapes[newIdx] = oldShapes[String(oldIdx)];
                    }
                });
                currentData.cutter_shapes = newShapes;
            }

            // Update groups array to match new indices
            if (currentData.groups && currentData.groups.length > 0) {
                currentData.groups = currentData.groups.map(oldGroup => {
                    const newGroup = indexMap[oldGroup] || indexMap[String(oldGroup)];
                    return newGroup !== undefined ? newGroup : oldGroup;
                });
            }

            // Update images.group_shapes group_text references if they exist
            if (currentData.images && currentData.images.group_shapes) {
                currentData.images.group_shapes.forEach(shape => {
                    if (shape.group_text) {
                        // group_text might be like "1,3,4" - update each number
                        const oldNums = shape.group_text.split(',').map(s => s.trim());
                        const newNums = oldNums.map(oldNum => {
                            const newNum = indexMap[oldNum] || indexMap[parseInt(oldNum)];
                            return newNum !== undefined ? String(newNum) : oldNum;
                        });
                        shape.group_text = newNums.join(',');
                    }
                });
            }

            refreshEditor();
            showMessage('BOM re-indexed to start from 1', 'success');
        }

        // Toggle Add Mode
        function toggleBomAddMode() {
            if (bomMode === 'add') {
                bomMode = null;
                selectedBomForAdd = null;
            } else {
                bomMode = 'add';
            }
            updateBomToolbarState();
            renderBomMergedTable();
            renderBladesEditor();
        }

        // Toggle Replace Mode
        function toggleBomReplaceMode() {
            if (bomMode === 'replace') {
                bomMode = null;
                selectedBomForAdd = null;
            } else {
                bomMode = 'replace';
            }
            updateBomToolbarState();
            renderBomMergedTable();
            renderBladesEditor();
        }

        // Select BOM item for add/replace mode
        function selectBomForMode(idx) {
            const item = currentData.summary[idx];
            if (!item) return;

            if (selectedBomForAdd && selectedBomForAdd.idx === idx) {
                // Deselect
                selectedBomForAdd = null;
            } else {
                selectedBomForAdd = { idx, item };
            }

            updateBomToolbarState();
            renderBomMergedTable();
            renderBladesEditor();
        }

        // Clear BOM selection
        function clearBomSelection() {
            selectedBomForAdd = null;
            updateBomToolbarState();
            renderBomMergedTable();
            renderBladesEditor();
        }

        // Update toolbar visual state
        function updateBomToolbarState() {
            const addBtn = document.getElementById('bomAddModeBtn');
            const replaceBtn = document.getElementById('bomReplaceModeBtn');
            const selectedInfo = document.getElementById('bomSelectedInfo');

            if (addBtn) {
                addBtn.classList.toggle('active', bomMode === 'add');
            }
            if (replaceBtn) {
                replaceBtn.classList.toggle('active', bomMode === 'replace');
                replaceBtn.classList.toggle('replace', bomMode === 'replace');
            }

            if (selectedInfo) {
                if (selectedBomForAdd) {
                    selectedInfo.style.display = 'flex';
                    document.getElementById('bomSelectedType').textContent = selectedBomForAdd.item.type;
                    document.getElementById('bomSelectedSize').textContent = selectedBomForAdd.item.size;
                } else {
                    selectedInfo.style.display = 'none';
                }
            }
        }

        // Handle cutter click in add/replace mode
        function handleCutterModeClick(e, bladeIdx, rowKey, pos, cellIdx) {
            e.stopPropagation();
            if (!bomMode || !selectedBomForAdd) return;

            const cell = currentData.blades[bladeIdx][rowKey][pos][cellIdx];
            const selectedItem = selectedBomForAdd.item;
            const oldBomIndex = cell.group;

            // Get cutter size from its BOM item (same logic as Edit Layout)
            const oldBomItem = currentData.summary.find(b => b.index === oldBomIndex);
            const cutterSize = oldBomItem ? normalizeSize(oldBomItem.size) : normalizeSize(cell.size || cell.originalSize || '');
            const selectedSize = normalizeSize(selectedItem.size);

            if (bomMode === 'add') {
                // Add mode: insert a copy of selected BOM cutter after this one
                saveToHistory();
                const newCutter = {
                    type: selectedItem.type,
                    group: selectedItem.index,
                    chamfer: selectedItem.chamfer,
                    size: selectedItem.size,
                    _isNew: true
                };
                currentData.blades[bladeIdx][rowKey][pos].splice(cellIdx + 1, 0, newCutter);

                // Update BOM count
                selectedItem.count = (parseInt(selectedItem.count) || 0) + 1;

                refreshEditor();
                setTimeout(clearNewCutterFlags, 1600);
                showMessage(`Added ${selectedItem.type} after position ${cellIdx + 1}`, 'success');

            } else if (bomMode === 'replace') {
                // Replace mode: only if same size (same logic as Edit Layout)
                if (cutterSize && cutterSize !== selectedSize) {
                    showMessage(`Size mismatch! This pocket is ${cutterSize}mm, but selected item is ${selectedSize}mm`, 'warning');
                    return;
                }

                // If cutter is already assigned to this BOM item, do nothing
                if (oldBomIndex === selectedItem.index) {
                    showMessage('Cutter already assigned to this BOM item', 'info');
                    return;
                }

                saveToHistory();

                // Decrease old BOM count
                if (oldBomItem && oldBomItem.count > 0) {
                    oldBomItem.count--;
                }

                // Update cutter to new BOM item
                cell.type = selectedItem.type;
                cell.group = selectedItem.index;
                cell.chamfer = selectedItem.chamfer;
                cell._isNew = true;

                // Increase new BOM count
                selectedItem.count = (parseInt(selectedItem.count) || 0) + 1;

                refreshEditor();
                setTimeout(clearNewCutterFlags, 1600);
                showMessage(`Replaced with ${selectedItem.type}`, 'success');
            }
        }

        // Update BOM quantity from merged table
        function updateBomQtyFromMerged(idx, value) {
            if (currentData.summary[idx]) {
                currentData.summary[idx].count = parseInt(value) || 0;
                renderBomMergedTable();
                updateStats();
            }
        }

        // Upload shape for BOM item
        function uploadBomShape(groupIndex, input) {
            if (!input.files || !input.files[0]) return;

            const file = input.files[0];
            const reader = new FileReader();

            reader.onload = function(e) {
                const dataUrl = e.target.result;
                if (!currentData.cutter_shapes) {
                    currentData.cutter_shapes = {};
                }
                currentData.cutter_shapes[groupIndex] = { data: dataUrl };
                renderBomMergedTable();
                renderBladesEditor();
                showMessage(`Shape updated for group ${groupIndex}`, 'success');
            };

            reader.readAsDataURL(file);
        }

        // Remove BOM item from merged table
        function removeBomItemFromMerged(idx) {
            const item = currentData.summary[idx];
            if (!item) return;

            const clCount = countCuttersForBomIndex(item.index);

            // If no cutters in CL, just confirm and remove
            if (clCount === 0) {
                if (confirm(`Remove "${item.type}" (${item.mat_number})?`)) {
                    executeRemoveBomFromMerged(idx, item, 'remove');
                }
                return;
            }

            // Show dialog with options for handling cutters
            showDeleteBomDialog(idx, item, clCount, 'merged', (action) => {
                executeRemoveBomFromMerged(idx, item, action);
            });
        }

        // Execute the actual removal from merged table
        function executeRemoveBomFromMerged(idx, item, action) {
            saveToHistory();

            if (action === 'placeholder') {
                // Mark cutters with this BOM index as placeholders
                (currentData.blades || []).forEach(blade => {
                    ['r1', 'r2', 'r3', 'r4'].forEach(rowKey => {
                        if (blade[rowKey]) {
                            Object.values(blade[rowKey]).forEach(cells => {
                                cells.forEach(cell => {
                                    if (cell.group === item.index) {
                                        cell.group = null;
                                        cell.type = '';
                                        cell.chamfer = '';
                                        cell._isPlaceholder = true;
                                    }
                                });
                            });
                        }
                    });
                });
            } else if (action === 'remove') {
                // Completely remove cutters from CL
                (currentData.blades || []).forEach(blade => {
                    ['r1', 'r2', 'r3', 'r4'].forEach(rowKey => {
                        if (blade[rowKey]) {
                            Object.keys(blade[rowKey]).forEach(pos => {
                                blade[rowKey][pos] = blade[rowKey][pos].filter(cell => cell.group !== item.index);
                            });
                        }
                    });
                });
            }

            currentData.summary.splice(idx, 1);

            // Re-index BOM items and update CL references
            const indexMapping = {}; // old index -> new index
            currentData.summary.forEach((it, i) => {
                const oldIndex = it.index;
                const newIndex = i + 1;
                indexMapping[oldIndex] = newIndex;
                it.index = newIndex;
            });

            // Update cutter group references to match new BOM indices
            (currentData.blades || []).forEach(blade => {
                ['r1', 'r2', 'r3', 'r4'].forEach(rowKey => {
                    if (blade[rowKey]) {
                        Object.values(blade[rowKey]).forEach(cells => {
                            cells.forEach(cell => {
                                if (cell.group > 0 && indexMapping[cell.group] !== undefined) {
                                    cell.group = indexMapping[cell.group];
                                }
                            });
                        });
                    }
                });
            });

            // Update cutter_shapes to match new indices
            if (currentData.cutter_shapes) {
                const newShapes = {};
                Object.keys(currentData.cutter_shapes).forEach(oldKey => {
                    const oldIndex = parseInt(oldKey) || oldKey;
                    const newIndex = indexMapping[oldIndex] || indexMapping[String(oldIndex)];
                    if (newIndex !== undefined) {
                        newShapes[String(newIndex)] = currentData.cutter_shapes[oldKey];
                    }
                });
                currentData.cutter_shapes = newShapes;
            }

            refreshEditor();
            showMessage('BOM item removed', 'success');
        }

        // Restore a deleted original BOM item
        function restoreDeletedBomItem(origIndex) {
            if (!originalData || !originalData.summary) return;

            const origItem = originalData.summary.find(item => item.index === origIndex);
            if (!origItem) return;

            saveToHistory();

            // Create a copy of the original item
            const restoredItem = { ...origItem };
            // Preserve original index for tracking after re-index
            restoredItem._originalIndex = origItem.index;
            // Not a new item - it's restored from original
            delete restoredItem._isNewItem;

            // Add to current summary (at end, will be re-indexed)
            currentData.summary.push(restoredItem);

            // Re-index all items (but preserve _originalIndex)
            currentData.summary.forEach((item, i) => {
                if (item._originalIndex === undefined && !item._isNewItem) {
                    item._originalIndex = item.index; // Preserve before re-indexing
                }
                item.index = i + 1;
            });

            refreshEditor();
            showMessage(`Restored "${origItem.type}" (${origItem.mat_number})`, 'success');
        }

        // Legacy function - kept for compatibility
        function renderBomComparison() {
            renderBomMergedTable();
        }

        // Count cutters in current CL by group number
        function countCuttersInCL() {
            const counts = {};
            (currentData.blades || []).forEach(blade => {
                ['r1', 'r2', 'r3', 'r4'].forEach(rowKey => {
                    if (blade[rowKey]) {
                        Object.values(blade[rowKey]).forEach(cells => {
                            cells.forEach(cell => {
                                const group = cell.group || 1;
                                counts[group] = (counts[group] || 0) + 1;
                            });
                        });
                    }
                });
            });
            return counts;
        }

        // Insert mode state
        let insertMode = null; // null, 'add', or 'clone'
        let insertData = null; // data for clone mode

        // Start add cutter mode - user selects position to add
        function startAddCutter(bladeIdx, rowKey) {
            // First check if there are positions with cutters
            const row = currentData.blades[bladeIdx][rowKey];
            const positions = ['CONE', 'NOSE', 'SHOULDER', 'GAUGE', 'PAD'];
            const hasAnyCutters = positions.some(p => row && row[p] && row[p].length > 0);

            if (!hasAnyCutters) {
                // No cutters yet, ask which position to add to
                const pos = prompt('Select position to add cutter:\nCONE, NOSE, SHOULDER, GAUGE, or PAD');
                if (pos && positions.includes(pos.toUpperCase())) {
                    addCutterToPosition(bladeIdx, rowKey, pos.toUpperCase(), 0);
                }
                return;
            }

            // Enter insert mode
            insertMode = 'add';
            insertData = { bladeIdx, rowKey };
            document.getElementById('bladesEditor').classList.add('insert-mode');
            document.getElementById('insertMessage').textContent = `Adding: ${selectedCutter.type} (Group ${selectedCutter.group}) - Click between cutters to place`;
            document.getElementById('insertIndicator').classList.add('active');

            // Listen for Escape key
            document.addEventListener('keydown', handleInsertEscape);
        }

        // Start clone mode - user selects position to place clone
        function startClone(bladeIdx, rowKey, pos, cellIdx) {
            const original = currentData.blades[bladeIdx][rowKey][pos][cellIdx];
            insertMode = 'clone';
            insertData = { bladeIdx, rowKey, pos, cellIdx, cutter: { ...original } };
            document.getElementById('bladesEditor').classList.add('insert-mode');
            document.getElementById('insertMessage').textContent = `Cloning: ${original.type} (Group ${original.group}) - Click between cutters to place`;
            document.getElementById('insertIndicator').classList.add('active');

            // Listen for Escape key
            document.addEventListener('keydown', handleInsertEscape);
        }

        // Handle Escape key to cancel insert mode
        function handleInsertEscape(e) {
            if (e.key === 'Escape') {
                cancelInsertMode();
            }
        }

        // Cancel insert mode
        function cancelInsertMode() {
            insertMode = null;
            insertData = null;
            document.getElementById('bladesEditor').classList.remove('insert-mode');
            document.getElementById('insertIndicator').classList.remove('active');
            document.removeEventListener('keydown', handleInsertEscape);
        }

        // Insert cutter at clicked position
        function insertCutterAt(bladeIdx, rowKey, pos, insertIdx) {
            if (!insertMode) return;

            let newCutter;
            if (insertMode === 'add') {
                newCutter = { ...selectedCutter, _isNew: true };
            } else if (insertMode === 'clone') {
                newCutter = { ...insertData.cutter, _isNew: true };
            }

            // Ensure row and position exist
            if (!currentData.blades[bladeIdx][rowKey]) {
                currentData.blades[bladeIdx][rowKey] = {};
            }
            if (!currentData.blades[bladeIdx][rowKey][pos]) {
                currentData.blades[bladeIdx][rowKey][pos] = [];
            }

            // Insert at position
            currentData.blades[bladeIdx][rowKey][pos].splice(insertIdx, 0, newCutter);

            // Exit insert mode
            cancelInsertMode();

            // Refresh and clear the _isNew flag after animation
            refreshEditor();
            setTimeout(() => {
                clearNewCutterFlags();
            }, 1600); // After 3 glow cycles (0.5s * 3)
        }

        // Add cutter to a specific position (for empty rows)
        function addCutterToPosition(bladeIdx, rowKey, pos, insertIdx) {
            if (!currentData.blades[bladeIdx][rowKey]) {
                currentData.blades[bladeIdx][rowKey] = {};
            }
            if (!currentData.blades[bladeIdx][rowKey][pos]) {
                currentData.blades[bladeIdx][rowKey][pos] = [];
            }

            const newCutter = { ...selectedCutter, _isNew: true };
            currentData.blades[bladeIdx][rowKey][pos].splice(insertIdx, 0, newCutter);

            refreshEditor();
            setTimeout(() => {
                clearNewCutterFlags();
            }, 1600);
        }

        // Clear _isNew flags from all cutters
        function clearNewCutterFlags() {
            (currentData.blades || []).forEach(blade => {
                ['r1', 'r2', 'r3', 'r4'].forEach(rowKey => {
                    if (blade[rowKey]) {
                        Object.values(blade[rowKey]).forEach(cells => {
                            cells.forEach(cell => {
                                delete cell._isNew;
                            });
                        });
                    }
                });
            });
        }

        // Legacy addCutterAt - redirects to new system
        function addCutterAt(bladeIdx, rowKey, pos, insertIdx = -1) {
            addCutterToPosition(bladeIdx, rowKey, pos, insertIdx >= 0 ? insertIdx : 0);
        }

        // Legacy cloneCutter - redirects to new system
        function cloneCutter(bladeIdx, rowKey, pos, cellIdx) {
            saveToHistory(); // Save state for undo
            const cells = currentData.blades[bladeIdx][rowKey][pos];
            const original = cells[cellIdx];
            const clone = { ...original, _isNew: true };
            cells.splice(cellIdx + 1, 0, clone);
            refreshEditor();
            setTimeout(() => {
                clearNewCutterFlags();
            }, 1600);
        }

        // Delete a cutter
        function deleteCutter(bladeIdx, rowKey, pos, cellIdx) {
            saveToHistory(); // Save state for undo

            const cells = currentData.blades[bladeIdx][rowKey][pos];
            cells.splice(cellIdx, 1);

            // Remove position if empty
            if (cells.length === 0) {
                delete currentData.blades[bladeIdx][rowKey][pos];
            }

            refreshEditor();
        }

        // Delete entire row
        function deleteRow(bladeIdx, rowKey) {
            if (confirm(`Delete row ${rowKey.toUpperCase()} from this blade?`)) {
                saveToHistory(); // Save state for undo
                currentData.blades[bladeIdx][rowKey] = {};
                refreshEditor();
            }
        }

        // Add a new row to blade (paste from clipboard or add empty)
        function addRowToBlade(bladeIdx) {
            const blade = currentData.blades[bladeIdx];
            const rows = ['r1', 'r2', 'r3', 'r4'];

            // Find first empty row
            let targetRow = null;
            for (const r of rows) {
                if (!hasRowData(blade[r])) {
                    targetRow = r;
                    break;
                }
            }

            if (!targetRow) {
                showMessage('No empty row available (R1-R4 all have data)', 'warning');
                return;
            }

            saveToHistory();

            if (rowClipboard) {
                // Paste from clipboard
                blade[targetRow] = JSON.parse(JSON.stringify(rowClipboard.data));
                // Mark cutters as new for glow effect
                Object.values(blade[targetRow]).forEach(posArr => {
                    if (Array.isArray(posArr)) {
                        posArr.forEach(c => c._isNew = true);
                    }
                });
                showMessage(`Pasted row to ${targetRow.toUpperCase()}`, 'success');
            } else {
                // Add empty row with one placeholder cutter
                blade[targetRow] = {
                    'CONE': [{ type: '', group: null, chamfer: '', _isPlaceholder: true }]
                };
                showMessage(`Added new row ${targetRow.toUpperCase()}`, 'success');
            }

            refreshEditor();
            setTimeout(clearNewCutterFlags, 1600);
        }

        // Move cutter within same row or to different position
        function moveCutter(fromBladeIdx, fromRowKey, fromPos, fromCellIdx, toBladeIdx, toRowKey, toPos, toCellIdx) {
            saveToHistory(); // Save state for undo
            // Get the cutter to move
            const cutter = currentData.blades[fromBladeIdx][fromRowKey][fromPos][fromCellIdx];

            // Remove from original position
            currentData.blades[fromBladeIdx][fromRowKey][fromPos].splice(fromCellIdx, 1);
            if (currentData.blades[fromBladeIdx][fromRowKey][fromPos].length === 0) {
                delete currentData.blades[fromBladeIdx][fromRowKey][fromPos];
            }

            // Add to new position
            if (!currentData.blades[toBladeIdx][toRowKey]) {
                currentData.blades[toBladeIdx][toRowKey] = {};
            }
            if (!currentData.blades[toBladeIdx][toRowKey][toPos]) {
                currentData.blades[toBladeIdx][toRowKey][toPos] = [];
            }

            if (toCellIdx >= 0) {
                currentData.blades[toBladeIdx][toRowKey][toPos].splice(toCellIdx, 0, cutter);
            } else {
                currentData.blades[toBladeIdx][toRowKey][toPos].push(cutter);
            }

            refreshEditor();
        }

        // Refresh editor and all related views
        function refreshEditor() {
            renderBladesEditor();
            renderBomComparison();
            updateStats();
            renderFullPage();
            renderLocations();
        }

        // Drag and drop state
        let dragData = null;

        function handleDragStart(e, bladeIdx, rowKey, pos, cellIdx) {
            dragData = { bladeIdx, rowKey, pos, cellIdx };
            e.target.classList.add('dragging');
            e.dataTransfer.effectAllowed = 'move';
            e.dataTransfer.setData('text/plain', JSON.stringify(dragData));
            // Show drop zones when dragging
            document.getElementById('bladesEditor').classList.add('insert-mode');
        }

        function handleDragEnd(e) {
            e.target.classList.remove('dragging');
            document.querySelectorAll('.drag-over').forEach(el => el.classList.remove('drag-over'));
            // Hide drop zones
            document.getElementById('bladesEditor').classList.remove('insert-mode');
            dragData = null;
        }

        function handleDragOver(e) {
            e.preventDefault();
            e.dataTransfer.dropEffect = 'move';
        }

        function handleDragEnter(e) {
            e.preventDefault();
            const dropZone = e.target.closest('.drop-zone');
            if (dropZone) dropZone.classList.add('drag-over');
        }

        function handleDragLeave(e) {
            const dropZone = e.target.closest('.drop-zone');
            if (dropZone) dropZone.classList.remove('drag-over');
        }

        function handleDrop(e) {
            e.preventDefault();
            const dropZone = e.target.closest('.drop-zone');
            if (dropZone) dropZone.classList.remove('drag-over');

            if (!dragData) return;

            // Get drop target info from data attributes
            const toBladeIdx = parseInt(dropZone?.dataset.blade);
            const toRowKey = dropZone?.dataset.row;
            const toPos = dropZone?.dataset.pos;
            const toCellIdx = parseInt(dropZone?.dataset.idx);

            if (isNaN(toBladeIdx) || !toRowKey || !toPos || isNaN(toCellIdx)) return;

            const { bladeIdx, rowKey, pos, cellIdx } = dragData;

            // Don't move to same position
            if (bladeIdx === toBladeIdx && rowKey === toRowKey && pos === toPos && cellIdx === toCellIdx) {
                return;
            }

            moveCutter(bladeIdx, rowKey, pos, cellIdx, toBladeIdx, toRowKey, toPos, toCellIdx);
        }

        // Row drag and drop state
        let rowDragData = null;

        function handleRowDragStart(e, bladeIdx, rowKey) {
            e.stopPropagation(); // Prevent blade drag from triggering
            rowDragData = { bladeIdx, rowKey };
            e.target.classList.add('dragging-row');
            e.dataTransfer.effectAllowed = 'move';
            e.dataTransfer.setData('text/plain', JSON.stringify({ type: 'row', ...rowDragData }));
            document.getElementById('bladesEditor').classList.add('row-drag-mode');
        }

        function handleRowDragEnd(e) {
            e.target.classList.remove('dragging-row');
            document.querySelectorAll('.row-drag-over').forEach(el => el.classList.remove('row-drag-over'));
            document.getElementById('bladesEditor').classList.remove('row-drag-mode');
            rowDragData = null;
        }

        function handleRowDrop(e) {
            e.preventDefault();
            e.stopPropagation();
            const targetRow = e.target.closest('.blade-row');
            if (!targetRow || !rowDragData) return;

            targetRow.classList.remove('row-drag-over');

            const targetBladeIdx = parseInt(targetRow.dataset.blade);
            const targetRowKey = targetRow.dataset.row;

            if (targetBladeIdx !== rowDragData.bladeIdx) {
                showMessage('Rows can only be reordered within the same blade', 'warning');
                return;
            }

            if (targetRowKey === rowDragData.rowKey) return;

            // Swap rows within the same blade
            saveToHistory();
            const blade = currentData.blades[rowDragData.bladeIdx];

            // Get row data
            const sourceData = blade[rowDragData.rowKey];
            const targetData = blade[targetRowKey];

            // Swap
            blade[rowDragData.rowKey] = targetData;
            blade[targetRowKey] = sourceData;

            showMessage(`Swapped ${rowDragData.rowKey.toUpperCase()} with ${targetRowKey.toUpperCase()}`, 'success');
            refreshEditor();
        }

        // ========== POSITION DRAG AND DROP ==========
        const POSITIONS_ORDER = ['CONE', 'NOSE', 'SHOULDER', 'GAUGE', 'PAD'];
        let posDragData = null;

        function getPositionIndex(pos) {
            return POSITIONS_ORDER.indexOf(pos);
        }

        function handlePosDragStart(e, bladeIdx, rowKey, pos) {
            e.stopPropagation();
            posDragData = { bladeIdx, rowKey, pos };
            e.target.classList.add('dragging');
            // Add ghost marker to show original position
            setTimeout(() => {
                e.target.classList.add('drag-ghost');
            }, 0);
            e.dataTransfer.effectAllowed = 'move';
            e.dataTransfer.setData('text/plain', JSON.stringify({ type: 'position', ...posDragData }));
        }

        function handlePosDragEnd(e) {
            e.target.classList.remove('dragging');
            document.querySelectorAll('.pos-label.drag-over').forEach(el => el.classList.remove('drag-over'));
            document.querySelectorAll('.pos-label.drag-ghost').forEach(el => el.classList.remove('drag-ghost'));
            posDragData = null;
        }

        function handlePosDragOver(e) {
            e.preventDefault();
            if (posDragData) {
                const label = e.target.closest('.pos-label');
                if (label) {
                    label.classList.add('drag-over');
                }
            }
        }

        function handlePosDragLeave(e) {
            const label = e.target.closest('.pos-label');
            if (label) {
                label.classList.remove('drag-over');
            }
        }

        function handlePosDrop(e, bladeIdx, rowKey, targetPos) {
            e.preventDefault();
            e.stopPropagation();
            document.querySelectorAll('.pos-label.drag-over').forEach(el => el.classList.remove('drag-over'));

            if (!posDragData || posDragData.bladeIdx !== bladeIdx || posDragData.rowKey !== rowKey) {
                showMessage('Positions can only be reordered within the same row', 'warning');
                return;
            }

            const sourcePos = posDragData.pos;
            if (sourcePos === targetPos) return;

            const blade = currentData.blades[bladeIdx];
            const rowData = blade[rowKey];
            if (!rowData) return;

            // Get active positions in current order
            const activePositions = POSITIONS_ORDER.filter(p => rowData[p] && rowData[p].length > 0);

            const sourceIdx = activePositions.indexOf(sourcePos);
            const targetIdx = activePositions.indexOf(targetPos);

            if (sourceIdx === -1 || targetIdx === -1) return;

            // Calculate new order after swap
            const newOrder = [...activePositions];
            newOrder.splice(sourceIdx, 1);
            newOrder.splice(targetIdx, 0, sourcePos);

            // Validate the new order respects POSITIONS_ORDER sequence
            if (!validatePositionOrder(newOrder)) {
                showMessage('Invalid order! Positions must follow: CONE â†’ NOSE â†’ SHOULDER â†’ GAUGE â†’ PAD', 'warning');
                return;
            }

            // Perform the swap by reordering the data
            saveToHistory();
            const newRowData = {};
            newOrder.forEach(pos => {
                newRowData[pos] = rowData[pos];
            });
            // Preserve any other properties
            Object.keys(rowData).forEach(key => {
                if (!POSITIONS_ORDER.includes(key)) {
                    newRowData[key] = rowData[key];
                }
            });
            blade[rowKey] = newRowData;

            refreshEditor();
            showMessage(`Moved ${sourcePos} ${sourceIdx < targetIdx ? 'after' : 'before'} ${targetPos}`, 'success');
        }

        function validatePositionOrder(positions) {
            // Check that the positions are in valid sequence
            let lastIdx = -1;
            for (const pos of positions) {
                const idx = getPositionIndex(pos);
                if (idx <= lastIdx) {
                    return false;
                }
                lastIdx = idx;
            }
            return true;
        }

        // Move position left (swap with previous)
        function movePosLeft(bladeIdx, rowKey, pos) {
            const blade = currentData.blades[bladeIdx];
            const rowData = blade[rowKey];
            if (!rowData) return;

            const activePositions = POSITIONS_ORDER.filter(p => rowData[p] && rowData[p].length > 0);
            const currentIdx = activePositions.indexOf(pos);

            if (currentIdx <= 0) return; // Already at start

            const targetPos = activePositions[currentIdx - 1];

            // Swap positions in data - this means swapping the actual position names
            // But we need to validate that the new configuration is valid
            // Since we're moving left, we're swapping with the previous position

            // Get the POSITIONS_ORDER indices
            const posOrderIdx = getPositionIndex(pos);
            const targetOrderIdx = getPositionIndex(targetPos);

            // After swap: targetPos would be where pos was, pos would be where targetPos was
            // This is always valid because we're just reordering existing positions

            saveToHistory();

            // Swap the cutters between positions
            const temp = rowData[pos];
            rowData[pos] = rowData[targetPos];
            rowData[targetPos] = temp;

            refreshEditor();
            showMessage(`Swapped ${pos} with ${targetPos}`, 'success');
        }

        // Move position right (swap with next)
        function movePosRight(bladeIdx, rowKey, pos) {
            const blade = currentData.blades[bladeIdx];
            const rowData = blade[rowKey];
            if (!rowData) return;

            const activePositions = POSITIONS_ORDER.filter(p => rowData[p] && rowData[p].length > 0);
            const currentIdx = activePositions.indexOf(pos);

            if (currentIdx >= activePositions.length - 1) return; // Already at end

            const targetPos = activePositions[currentIdx + 1];

            saveToHistory();

            // Swap the cutters between positions
            const temp = rowData[pos];
            rowData[pos] = rowData[targetPos];
            rowData[targetPos] = temp;

            refreshEditor();
            showMessage(`Swapped ${pos} with ${targetPos}`, 'success');
        }

        // Toggle position replacement dropdown
        let activePosDropdown = null;

        function togglePosDropdown(e, bladeIdx, rowKey, currentPos) {
            e.stopPropagation();

            // Close any existing dropdown
            closePosDropdown();

            const blade = currentData.blades[bladeIdx];
            const rowData = blade[rowKey];
            if (!rowData) return;

            const activePositions = POSITIONS_ORDER.filter(p => rowData[p] && rowData[p].length > 0);
            const currentPosIdx = activePositions.indexOf(currentPos);

            // Find valid replacement positions
            // A position can be replaced if it doesn't break the sequence
            const availablePositions = POSITIONS_ORDER.filter(p => {
                if (activePositions.includes(p)) return false; // Already in use

                // Check if replacing currentPos with p would be valid
                const testPositions = [...activePositions];
                testPositions[currentPosIdx] = p;
                return validatePositionOrder(testPositions);
            });

            const dropdownId = `pos-dropdown-${bladeIdx}-${rowKey}-${currentPos}`;
            const dropdown = document.getElementById(dropdownId);

            if (!dropdown) return;

            dropdown.innerHTML = '<div class="pos-dropdown-header">Replace with:</div>';

            // Current position (shown as selected)
            const currentItem = document.createElement('div');
            currentItem.className = 'pos-dropdown-item current';
            currentItem.textContent = currentPos + ' (current)';
            dropdown.appendChild(currentItem);

            if (availablePositions.length === 0) {
                const noItem = document.createElement('div');
                noItem.className = 'pos-dropdown-item disabled';
                noItem.textContent = 'No valid replacements';
                dropdown.appendChild(noItem);
            } else {
                availablePositions.forEach(newPos => {
                    const item = document.createElement('div');
                    item.className = 'pos-dropdown-item';
                    item.textContent = newPos;
                    item.onclick = (ev) => {
                        ev.stopPropagation();
                        replacePosition(bladeIdx, rowKey, currentPos, newPos);
                        closePosDropdown();
                    };
                    dropdown.appendChild(item);
                });
            }

            dropdown.classList.add('visible');
            activePosDropdown = dropdown;

            // Close on outside click
            setTimeout(() => {
                document.addEventListener('click', closePosDropdown, { once: true });
            }, 10);
        }

        function closePosDropdown() {
            if (activePosDropdown) {
                activePosDropdown.classList.remove('visible');
                activePosDropdown = null;
            }
        }

        // Replace one position with another
        function replacePosition(bladeIdx, rowKey, oldPos, newPos) {
            const blade = currentData.blades[bladeIdx];
            const rowData = blade[rowKey];
            if (!rowData || !rowData[oldPos]) return;

            saveToHistory();

            // Move cutters from old position to new position
            rowData[newPos] = rowData[oldPos];
            delete rowData[oldPos];

            refreshEditor();
            showMessage(`Changed ${oldPos} to ${newPos}`, 'success');
        }

        function deletePosition(bladeIdx, rowKey, pos) {
            const blade = currentData.blades[bladeIdx];
            const rowData = blade[rowKey];
            if (!rowData || !rowData[pos]) return;

            const cutterCount = rowData[pos].length;
            if (cutterCount > 0) {
                if (!confirm(`Delete ${pos} position with ${cutterCount} cutter(s)?`)) {
                    return;
                }
            }

            saveToHistory();
            delete rowData[pos];

            // Check if row is now empty
            const hasData = POSITIONS_ORDER.some(p => rowData[p] && rowData[p].length > 0);
            if (!hasData) {
                delete blade[rowKey];
            }

            refreshEditor();
            showMessage(`Removed ${pos} position`, 'success');
        }

        let addPositionMenu = null;

        function showAddPositionMenu(e, bladeIdx, rowKey) {
            e.stopPropagation();

            // Close existing menu
            closeAddPositionMenu();

            const blade = currentData.blades[bladeIdx];
            const rowData = blade[rowKey] || {};

            // Get active positions
            const activePositions = POSITIONS_ORDER.filter(p => rowData[p] && rowData[p].length > 0);

            // Find available positions (not already in use)
            const availablePositions = POSITIONS_ORDER.filter(p => !activePositions.includes(p));

            if (availablePositions.length === 0) {
                showMessage('All positions are already in use', 'info');
                return;
            }

            // Determine valid positions (must maintain sequence, no gaps)
            const validPositions = availablePositions.filter(pos => {
                const posIdx = getPositionIndex(pos);
                // Can add at start if first active position is after this one
                // Can add at end if last active position is before this one
                // Can add in middle only if it fills a gap
                if (activePositions.length === 0) return true;

                const firstActiveIdx = getPositionIndex(activePositions[0]);
                const lastActiveIdx = getPositionIndex(activePositions[activePositions.length - 1]);

                // Valid if adjacent to existing positions
                return posIdx === firstActiveIdx - 1 || posIdx === lastActiveIdx + 1;
            });

            // Create menu
            const menu = document.createElement('div');
            menu.className = 'add-position-menu';
            menu.style.left = e.pageX + 'px';
            menu.style.top = e.pageY + 'px';

            availablePositions.forEach(pos => {
                const isValid = validPositions.includes(pos);
                const item = document.createElement('div');
                item.className = 'add-position-menu-item' + (isValid ? '' : ' disabled');
                item.textContent = pos;
                if (isValid) {
                    item.onclick = () => {
                        addPosition(bladeIdx, rowKey, pos);
                        closeAddPositionMenu();
                    };
                } else {
                    item.title = 'Cannot add: would create gap in sequence';
                }
                menu.appendChild(item);
            });

            document.body.appendChild(menu);
            addPositionMenu = menu;

            // Close on click outside
            setTimeout(() => {
                document.addEventListener('click', closeAddPositionMenu, { once: true });
            }, 0);
        }

        function closeAddPositionMenu() {
            if (addPositionMenu) {
                addPositionMenu.remove();
                addPositionMenu = null;
            }
        }

        function addPosition(bladeIdx, rowKey, pos) {
            const blade = currentData.blades[bladeIdx];
            if (!blade[rowKey]) blade[rowKey] = {};

            saveToHistory();

            // Add empty position with placeholder cutter (no index assigned)
            blade[rowKey][pos] = [{
                type: '',
                group: null,  // No index assigned - placeholder
                chamfer: '',
                _isPlaceholder: true  // Keeps glowing until assigned
            }];

            refreshEditor();
            showMessage(`Added ${pos} position - click to assign cutter type`, 'info');
        }

        // Blade drag and drop state
        let bladeDragData = null;

        function handleBladeDragStart(e, bladeIdx) {
            bladeDragData = { bladeIdx };
            e.target.classList.add('dragging-blade');
            e.dataTransfer.effectAllowed = 'move';
            e.dataTransfer.setData('text/plain', JSON.stringify({ type: 'blade', bladeIdx }));
            document.getElementById('bladesEditor').classList.add('blade-drag-mode');
        }

        function handleBladeDragEnd(e) {
            e.target.classList.remove('dragging-blade');
            document.querySelectorAll('.blade-drag-over').forEach(el => el.classList.remove('blade-drag-over'));
            document.getElementById('bladesEditor').classList.remove('blade-drag-mode');
            bladeDragData = null;
        }

        function handleBladeDrop(e) {
            e.preventDefault();
            const targetBlade = e.target.closest('.blade-block');
            if (!targetBlade || !bladeDragData) return;

            targetBlade.classList.remove('blade-drag-over');

            const targetIdx = parseInt(targetBlade.dataset.bladeIdx);
            if (isNaN(targetIdx) || targetIdx === bladeDragData.bladeIdx) return;

            // Reorder blades
            saveToHistory();
            const blades = currentData.blades;
            const sourceIdx = bladeDragData.bladeIdx;

            // Remove source blade and insert at target position
            const [movedBlade] = blades.splice(sourceIdx, 1);
            blades.splice(targetIdx, 0, movedBlade);

            // Renumber blades
            blades.forEach((b, i) => {
                b.name = `B${i + 1}`;
            });

            showMessage(`Blade moved to position ${targetIdx + 1}`, 'success');
            refreshEditor();
        }

        // Setup dragover/dragenter for row and blade targets
        document.addEventListener('dragover', function(e) {
            if (rowDragData) {
                const targetRow = e.target.closest('.blade-row');
                if (targetRow && targetRow.dataset.blade == rowDragData.bladeIdx) {
                    e.preventDefault();
                    targetRow.classList.add('row-drag-over');
                }
            }
            if (bladeDragData) {
                const targetBlade = e.target.closest('.blade-block');
                if (targetBlade) {
                    e.preventDefault();
                    targetBlade.classList.add('blade-drag-over');
                }
            }
        });

        document.addEventListener('dragleave', function(e) {
            const targetRow = e.target.closest('.blade-row');
            if (targetRow) targetRow.classList.remove('row-drag-over');
            const targetBlade = e.target.closest('.blade-block');
            if (targetBlade) targetBlade.classList.remove('blade-drag-over');
        });

        document.addEventListener('drop', function(e) {
            if (rowDragData) {
                handleRowDrop(e);
            } else if (bladeDragData) {
                handleBladeDrop(e);
            }
        });

        // Open edit modal for a cutter
        function openEditCutterModal(bladeIdx, rowKey, pos, cellIdx) {
            const cell = currentData.blades[bladeIdx][rowKey][pos][cellIdx];
            document.getElementById('modalTitle').textContent = 'Edit Cutter';
            document.getElementById('modalSaveBtn').textContent = 'Save Changes';
            document.getElementById('modalBladeIdx').value = bladeIdx;
            document.getElementById('modalRow').value = rowKey;
            document.getElementById('modalPos').value = pos;
            document.getElementById('modalCellIdx').value = cellIdx;
            document.getElementById('modalCutterType').value = cell.type || 'CT418';
            document.getElementById('modalGroup').value = cell.group || 1;
            document.getElementById('modalChamfer').value = cell.chamfer || '';
            document.getElementById('modalEditMode').value = 'edit';
            // Reset and load shape preview for cutter's group
            document.getElementById('modalShapeData').value = '';
            document.getElementById('modalShapeUpload').value = '';
            updateModalShapePreview(cell.group || 1);
            document.getElementById('cutterModal').classList.add('active');
        }

        // Update saveCutter to handle edit/insert modes
        function saveCutterEnhanced() {
            const bi = parseInt(document.getElementById('modalBladeIdx').value);
            const row = document.getElementById('modalRow').value;
            const pos = document.getElementById('modalPos').value;
            const editMode = document.getElementById('modalEditMode').value;
            const cellIdx = parseInt(document.getElementById('modalCellIdx').value);
            const groupNum = parseInt(document.getElementById('modalGroup').value) || 1;
            const shapeData = document.getElementById('modalShapeData').value;

            const cutterData = {
                type: document.getElementById('modalCutterType').value,
                group: groupNum,
                chamfer: document.getElementById('modalChamfer').value,
                _isNew: editMode !== 'edit'
            };

            // Handle shape data - save to cutter_shapes if new shape uploaded
            if (shapeData) {
                if (!currentData.cutter_shapes) {
                    currentData.cutter_shapes = {};
                }
                currentData.cutter_shapes[groupNum] = { data: shapeData };
            }

            if (!currentData.blades[bi][row]) currentData.blades[bi][row] = {};
            if (!currentData.blades[bi][row][pos]) currentData.blades[bi][row][pos] = [];

            if (editMode === 'edit') {
                currentData.blades[bi][row][pos][cellIdx] = cutterData;
            } else if (editMode === 'insert' && cellIdx >= 0) {
                // Insert at specific position
                currentData.blades[bi][row][pos].splice(cellIdx, 0, cutterData);
            } else {
                // Add at end
                currentData.blades[bi][row][pos].push(cutterData);
            }

            closeCutterModal();
            refreshEditor();
            if (editMode !== 'edit') {
                setTimeout(clearNewCutterFlags, 1600);
            }
        }

        function updateStats() {
            const blades = currentData.blades || [];
            let totalCutters = 0;

            // Count circles (each cell = 1 cutter) - dynamic R1-R4
            blades.forEach(blade => {
                ['r1', 'r2', 'r3', 'r4'].forEach(row => {
                    if (blade[row]) {
                        Object.values(blade[row]).forEach(cells => {
                            totalCutters += cells.length;  // Each cell = 1 cutter
                        });
                    }
                });
            });

            document.getElementById('statBlades').textContent = blades.length;
            document.getElementById('statCutters').textContent = totalCutters;
            document.getElementById('statTypes').textContent = (currentData.summary || []).length;
        }
        
        function renderFullPage() {
            // Get data based on active view (original or modified)
            const viewData = (fullPageView === 'original' && originalData) ? originalData : currentData;

            // Get groups from extracted data
            const groups = viewData.groups || [];
            const showGroupLegend = viewData.has_group_legend === true;
            const images = viewData.images || {};

            // Update view toggle button states
            document.querySelectorAll('.fullpage-toolbar .view-btn').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.view === fullPageView);
            });

            // Update change indicator
            updateViewChangeIndicator();

            let html = '';

            // Header frame with logo (left 42%) and info (right) - table layout
            html += `<div class="doc-header-frame">`;
            html += `<div class="doc-header-inner">`;

            // Logo area - fixed width even if no logo
            html += `<div class="doc-logo">`;
            if (images.halliburton_logo && images.halliburton_logo.data) {
                html += `<img src="${images.halliburton_logo.data}" alt="Halliburton">`;
            }
            html += `</div>`;

            // Header info - table cell
            // Row 1: SN Number, Mat Number, Date Created (3 fields)
            // Row 2: Revision Level, ADesc Software Version (2 fields)
            // For Original view: use originalData values; for Modified view: use input field values
            const headerValues = (fullPageView === 'original' && originalData) ? {
                sn_number: originalData.header.sn_number || '0',
                mat_number: originalData.header.mat_number || '',
                date_created: originalData.header.date_created || '',
                revision_level: originalData.header.revision_level || '',
                software_version: originalData.header.software_version || ''
            } : {
                sn_number: document.getElementById('snNumber').value,
                mat_number: document.getElementById('matNumber').value,
                date_created: document.getElementById('dateCreated').value || '',
                revision_level: document.getElementById('revisionLevel').value,
                software_version: document.getElementById('softwareVersion').value
            };

            html += `<div class="doc-header-info">
                <div class="doc-header-row">
                    <div class="doc-header-item"><span class="doc-header-label">SN Number: </span><span class="doc-header-value">${headerValues.sn_number}</span></div>
                    <div class="doc-header-item"><span class="doc-header-label">Mat Number: </span><span class="doc-header-value">${headerValues.mat_number}</span></div>
                    <div class="doc-header-item"><span class="doc-header-label">Date Created: </span><span class="doc-header-value">${headerValues.date_created}</span></div>
                </div>
                <div class="doc-header-row">
                    <div class="doc-header-item"><span class="doc-header-label">Revision Level: </span><span class="doc-header-value">${headerValues.revision_level}</span></div>
                    <div class="doc-header-item"><span class="doc-header-label">ADesc Software Version: </span><span class="doc-header-value">${headerValues.software_version}</span></div>
                </div>
            </div>`;

            html += `</div></div>`;

            // Content area: BOM table + Group table + Drill bit preview
            // cutter_shapes is a top-level key, not inside images
            const cutterShapes = viewData.cutter_shapes || {};
            html += `<div class="doc-content">
                <div class="doc-bom">
                    <table>
                        <thead><tr><th>#</th><th>Size</th><th>Chamfer</th><th>Type</th><th>Count</th><th>Mat #</th><th>Family #</th></tr></thead>
                        <tbody>`;

            (viewData.summary || []).forEach(r => {
                html += `<tr><td>${r.index}</td><td>${r.size}</td><td>${r.chamfer}</td><td>${r.type}</td><td>${r.count}</td><td>${r.mat_number}</td><td>${r.family_number||''}</td></tr>`;
            });

            html += `</tbody></table></div>`;

            // Group Legend - vertical table layout like PDF
            // Show ONLY proper group shapes extracted from PDF Group area (header)
            // Do NOT show CL shapes or any fallbacks
            if (groups.length > 0) {
                const groupShapes = images.group_shapes || [];

                html += `<div class="doc-group-legend">`;

                // Header row
                html += `<div class="group-legend-header">
                    <div class="group-legend-header-shape">#</div>
                    <div class="group-legend-header-group">Group</div>
                </div>`;

                // Show only properly extracted group shapes (from PDF header area)
                if (groupShapes.length > 0) {
                    groupShapes.forEach((shape, idx) => {
                        html += `<div class="group-legend-row">
                            <div class="group-legend-cell">`;
                        if (shape.data) {
                            html += `<img src="${shape.data}" class="group-shape-img" alt="Shape">`;
                        }
                        html += `</div>
                            <div class="group-legend-cell">
                                <span class="group-values">${shape.group_text || ''}</span>
                            </div>
                        </div>`;
                    });
                } else {
                    // No group shapes found - show just group numbers without shapes
                    groups.forEach((group, idx) => {
                        html += `<div class="group-legend-row">
                            <div class="group-legend-cell">${idx + 1}</div>
                            <div class="group-legend-cell">
                                <span class="group-values">${group}</span>
                            </div>
                        </div>`;
                    });
                }

                html += `</div>`;
            }

            // Drill bit preview (far right) - drill_bit_image is a top-level key
            const drillBitImg = viewData.drill_bit_image || images.drill_bit_preview || images.drill_bit_face;
            if (drillBitImg && drillBitImg.data) {
                html += `<div class="doc-drill-preview"><img src="${drillBitImg.data}" alt="Drill Bit"></div>`;
            }

            html += `</div>`;

            // Blades section
            (viewData.blades || []).forEach(blade => {
                html += renderBladePreview(blade);
            });

            document.getElementById('docPreview').innerHTML = html;
        }

        // POS_SYMBOLS is defined globally at the top of the script

        function renderLocations() {
            if (!currentData || !currentData.blades) {
                document.getElementById('locationsContent').innerHTML = '<p>No blade data available.</p>';
                return;
            }

            const positionsOrder = ['CONE', 'NOSE', 'SHOULDER', 'GAUGE', 'PAD'];
            let html = '';

            currentData.blades.forEach(blade => {
                html += `<div class="loc-blade-section">`;
                html += `<div class="loc-blade-header">${blade.name}</div>`;

                // Process each row (R1, R2, R3, R4)
                ['r1', 'r2', 'r3', 'r4'].forEach(rowKey => {
                    const rowData = blade[rowKey];
                    if (!rowData || !hasRowData(rowData)) return;

                    // Collect all cutters in order with their positions
                    const cuttersList = [];

                    positionsOrder.forEach(pos => {
                        const cells = rowData[pos] || [];
                        cells.forEach(cell => {
                            cuttersList.push({
                                group: cell.group || cell.qty || 1,
                                position: pos,
                                symbol: POS_SYMBOLS[pos]
                            });
                        });
                    });

                    if (cuttersList.length === 0) return;

                    html += `<div class="loc-row-section">`;
                    html += `<div class="loc-row-label">${rowKey.toUpperCase()}</div>`;

                    // Row 1: Group numbers
                    html += `<div class="loc-data-row groups">`;
                    cuttersList.forEach(c => {
                        html += `<div class="loc-item">${c.group}</div>`;
                    });
                    html += `</div>`;

                    // Row 2: Position labels (show when position changes)
                    html += `<div class="loc-data-row positions">`;
                    let lastPos = '';
                    cuttersList.forEach(c => {
                        if (c.position !== lastPos) {
                            html += `<div class="loc-item"><span class="loc-pos-label">${c.position.substring(0,3)}</span></div>`;
                            lastPos = c.position;
                        } else {
                            html += `<div class="loc-item"></div>`;
                        }
                    });
                    html += `</div>`;

                    // Row 3: Position symbols
                    html += `<div class="loc-data-row symbols">`;
                    cuttersList.forEach(c => {
                        html += `<div class="loc-item"><span class="loc-symbol loc-${c.symbol}">${c.symbol}</span></div>`;
                    });
                    html += `</div>`;

                    html += `</div>`; // loc-row-section
                });

                html += `</div>`; // loc-blade-section
            });

            document.getElementById('locationsContent').innerHTML = html;
        }

        // ========== EDIT LAYOUT FUNCTIONS ==========

        function setEditMode(mode) {
            editState.mode = mode;
            document.querySelectorAll('.mode-btn').forEach(btn => btn.classList.remove('active'));
            document.querySelector(`.mode-btn[onclick="setEditMode('${mode}')"]`).classList.add('active');
            const container = document.getElementById('editLayoutContainer');
            if (mode === 'review') {
                container.classList.add('review-mode');
            } else {
                container.classList.remove('review-mode');
            }
        }

        // ========== FULL PAGE VIEW TOGGLE ==========
        function setFullPageView(view) {
            fullPageView = view;
            // Update toggle buttons
            document.querySelectorAll('.fullpage-toolbar .view-btn').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.view === view);
            });
            // Update change indicator
            updateViewChangeIndicator();
            // Re-render full page
            renderFullPage();
        }

        function updateViewChangeIndicator() {
            const indicator = document.getElementById('viewChangeIndicator');
            const countEl = document.getElementById('viewChangeCount');

            if (!originalData || !currentData) {
                indicator.style.display = 'none';
                return;
            }

            // Count changes between original and modified
            let bomChanges = 0;
            let clChanges = 0;
            const origSummary = originalData.summary || [];
            const currSummary = currentData.summary || [];

            // Check BOM changes
            origSummary.forEach((orig, i) => {
                const curr = currSummary[i];
                if (!curr) {
                    bomChanges++;
                } else if (orig.count !== curr.count || orig.mat_number !== curr.mat_number ||
                           orig.type !== curr.type || orig.chamfer !== curr.chamfer ||
                           orig.size !== curr.size || orig.family_number !== curr.family_number) {
                    bomChanges++;
                }
            });
            // Check for new items
            if (currSummary.length > origSummary.length) {
                bomChanges += (currSummary.length - origSummary.length);
            }
            // Check for deleted items
            if (currSummary.length < origSummary.length) {
                bomChanges += (origSummary.length - currSummary.length);
            }

            // Check CL (blade/cutter) changes
            const origBlades = originalData.blades || [];
            const currBlades = currentData.blades || [];

            for (let bi = 0; bi < Math.max(origBlades.length, currBlades.length); bi++) {
                const origBlade = origBlades[bi] || {};
                const currBlade = currBlades[bi] || {};

                ['r1', 'r2', 'r3', 'r4'].forEach(rowKey => {
                    const origRow = origBlade[rowKey] || {};
                    const currRow = currBlade[rowKey] || {};

                    ['CONE', 'NOSE', 'SHOULDER', 'GAUGE', 'PAD'].forEach(pos => {
                        const origCells = origRow[pos] || [];
                        const currCells = currRow[pos] || [];

                        for (let ci = 0; ci < Math.max(origCells.length, currCells.length); ci++) {
                            const origCell = origCells[ci] || {};
                            const currCell = currCells[ci] || {};

                            // Check if cutter assignment changed
                            if (origCell.group !== currCell.group ||
                                origCell.type !== currCell.type ||
                                origCell.chamfer !== currCell.chamfer) {
                                clChanges++;
                            }
                        }
                    });
                });
            }

            const totalChanges = bomChanges + clChanges;

            if (totalChanges > 0) {
                let changeText = '';
                if (bomChanges > 0 && clChanges > 0) {
                    changeText = `${bomChanges} BOM + ${clChanges} CL`;
                } else if (bomChanges > 0) {
                    changeText = `${bomChanges} BOM`;
                } else {
                    changeText = `${clChanges} CL`;
                }
                indicator.innerHTML = `Changes: <strong>${changeText}</strong> modifications`;
                indicator.style.display = 'inline-block';
                indicator.classList.remove('no-changes');
            } else {
                indicator.innerHTML = '<strong>No changes</strong> from original';
                indicator.style.display = 'inline-block';
                indicator.classList.add('no-changes');
            }
        }

        function getActiveViewData() {
            // Returns the data to use for exports based on active view
            if (fullPageView === 'original' && originalData) {
                return originalData;
            }
            return currentData;
        }

        function renderEditLayout() {
            if (!currentData) return;
            renderEditBom();
            renderEditCL();
            renderEditValidation();

            // Update MAT display
            const matDisplay = document.getElementById('newMatDisplay');
            if (editState.newMatSuffix) {
                matDisplay.textContent = currentData.header.mat_number + editState.newMatSuffix;
            } else {
                matDisplay.textContent = 'Not set';
            }
        }

        function renderEditBom() {
            const container = document.getElementById('editBomList');
            if (!currentData || !currentData.summary) {
                container.innerHTML = '<p style="color:#999;">No BOM data</p>';
                return;
            }

            // Update fold indicator
            updateBomFoldIndicator();

            // Get selected item's size for highlighting and folding
            let selectedSize = null;
            let selectedNormalizedSize = null;
            if (editState.selectedBomIndex !== null && currentData.summary[editState.selectedBomIndex]) {
                selectedSize = currentData.summary[editState.selectedBomIndex].size;
                selectedNormalizedSize = normalizeSize(selectedSize);
            }

            let html = '';

            // Add info message when folded
            if (editState.bomFolded && selectedNormalizedSize) {
                const selectedBom = currentData.summary[editState.selectedBomIndex];
                html += `<div style="background:#e3f2fd;padding:8px 12px;border-radius:4px;margin-bottom:10px;font-size:11px;color:#1565c0;">
                    <strong>ðŸ“Œ Folded View:</strong> Showing only ${selectedNormalizedSize}mm BOM items (matching #${selectedBom.index})
                </div>`;
            }

            currentData.summary.forEach((item, idx) => {
                const colorIdx = (idx % BOM_COLORS.length) + 1;
                const isSelected = editState.selectedBomIndex === idx;
                const clCount = countCuttersForBomIndex(idx + 1);
                const isValid = clCount === item.count;

                // Check if item should be hidden when fold is ON
                const itemNormalizedSize = normalizeSize(item.size);
                const shouldHide = editState.bomFolded && selectedNormalizedSize && itemNormalizedSize !== selectedNormalizedSize;

                // Highlight same-size items
                const isSameSize = selectedSize && item.size === selectedSize && !isSelected;
                const sizeHighlight = isSameSize ? 'same-size-highlight' : '';
                const foldedHiddenClass = shouldHide ? 'folded-hidden' : '';

                // Build MAT dropdown options
                const matOptions = buildMatOptionsForSize(item.size, item.mat_number);

                // Build replacement info display with full details
                let replacesInfo = '';
                if (item.replacesOriginal && item.replacesOriginal.length > 0) {
                    const replacedDetails = item.replacesOriginal.map(r =>
                        `#${r.originalIndex} ${r.mat_number} (${r.type || 'N/A'}${r.chamfer ? ', ' + r.chamfer : ''})`
                    ).join('; ');
                    replacesInfo = `<div class="edit-bom-replaces" style="font-size:9px;color:#666;margin-top:2px;">
                        <span style="color:#1976d2;">â†© Replaces:</span> ${replacedDetails}
                    </div>`;
                }

                html += `<div class="edit-bom-item ${isSelected ? 'selected' : ''} ${sizeHighlight} ${foldedHiddenClass}" onclick="selectBomItem(${idx})" style="position:relative;">
                    <div class="edit-bom-header">
                        <div class="edit-bom-index bom-color-${colorIdx}">${item.index}</div>
                        <div class="edit-bom-mat">${item.mat_number}</div>
                        <span class="edit-bom-size-badge">${item.size}</span>
                    </div>
                    <div class="edit-bom-details">
                        <span>${item.type}</span>
                        <span>${item.chamfer}</span>
                        <span class="edit-bom-qty" style="background:${isValid ? '#c8e6c9' : '#ffcdd2'};">
                            Qty: ${item.count} ${isValid ? 'âœ“' : `(CL: ${clCount})`}
                        </span>
                    </div>
                    ${replacesInfo}
                    <div class="edit-bom-actions">
                        <button onclick="event.stopPropagation(); toggleFillPanel(${idx})" style="background:#2196F3;color:white;border:none;">
                            âš¡ Fill
                        </button>
                        <div id="fillPanel${idx}" class="fill-options-panel" onclick="event.stopPropagation()">
                            <h4>Fill Options for Item ${item.index}</h4>
                            ${buildSameSizeCutterOptions(idx)}
                            ${item.replacesOriginal && item.replacesOriginal.length > 0 ? `
                            <div class="fill-options-group" style="background:#e3f2fd;border-radius:4px;padding:5px;">
                                <label class="fill-checkbox-label" style="color:#1565c0;font-weight:bold;">
                                    <input type="checkbox" value="original_locations_only" data-bom="${idx}">
                                    Original Locations Only (replaces #${item.replacesOriginal.map(r => r.originalIndex).join(', #')})
                                </label>
                            </div>
                            ` : ''}
                            <div class="fill-options-group">
                                <div class="fill-options-group-label">Positions:</div>
                                <div class="fill-options-row">
                                    <label class="fill-checkbox-label"><input type="checkbox" value="cone_only" data-bom="${idx}"> CONE</label>
                                    <label class="fill-checkbox-label"><input type="checkbox" value="nose_only" data-bom="${idx}"> NOSE</label>
                                    <label class="fill-checkbox-label"><input type="checkbox" value="shoulder_only" data-bom="${idx}"> SHOULDER</label>
                                    <label class="fill-checkbox-label"><input type="checkbox" value="gauge_only" data-bom="${idx}"> GAUGE</label>
                                    <label class="fill-checkbox-label"><input type="checkbox" value="pad_only" data-bom="${idx}"> PAD</label>
                                </div>
                            </div>
                            <div class="fill-options-group">
                                <div class="fill-options-group-label">Rows:</div>
                                <div class="fill-options-row">
                                    <label class="fill-checkbox-label"><input type="checkbox" value="r1_only" data-bom="${idx}"> R1</label>
                                    <label class="fill-checkbox-label"><input type="checkbox" value="r2_only" data-bom="${idx}"> R2</label>
                                    <label class="fill-checkbox-label"><input type="checkbox" value="r3_only" data-bom="${idx}"> R3</label>
                                    <label class="fill-checkbox-label"><input type="checkbox" value="r4_only" data-bom="${idx}"> R4</label>
                                </div>
                            </div>
                            <div class="fill-options-group" style="background:#fff3e0;border-radius:4px;padding:5px;">
                                <div class="fill-options-group-label" style="color:#e65100;">Cutter Selection (per position):</div>
                                <div class="fill-options-row" style="flex-wrap:wrap;">
                                    <label class="fill-checkbox-label"><input type="radio" name="cutterSelect${idx}" value="all_cutters" data-bom="${idx}" checked> All</label>
                                    <label class="fill-checkbox-label"><input type="radio" name="cutterSelect${idx}" value="first_cutter" data-bom="${idx}"> 1st</label>
                                    <label class="fill-checkbox-label"><input type="radio" name="cutterSelect${idx}" value="first_two" data-bom="${idx}"> 1st Two</label>
                                    <label class="fill-checkbox-label"><input type="radio" name="cutterSelect${idx}" value="last_cutter" data-bom="${idx}"> Last</label>
                                    <label class="fill-checkbox-label"><input type="radio" name="cutterSelect${idx}" value="last_two" data-bom="${idx}"> Last Two</label>
                                    <label class="fill-checkbox-label"><input type="radio" name="cutterSelect${idx}" value="second_to_last" data-bom="${idx}"> 2nd to Last</label>
                                </div>
                            </div>
                            <div class="fill-options-group" style="background:#e8f5e9;border-radius:4px;padding:5px;">
                                <div class="fill-options-group-label" style="color:#2e7d32;">Distribution Mode:</div>
                                <div class="fill-options-row">
                                    <label class="fill-checkbox-label"><input type="radio" name="distMode${idx}" value="sequential" data-bom="${idx}" checked> Sequential (fill each row fully)</label>
                                    <label class="fill-checkbox-label"><input type="radio" name="distMode${idx}" value="round_robin" data-bom="${idx}"> Round-robin (1 per row, cycle)</label>
                                </div>
                            </div>
                            <button class="fill-apply-btn" onclick="event.stopPropagation(); applyFillOptions(${idx})">
                                Apply Selected Filters
                            </button>
                        </div>
                        <button onclick="event.stopPropagation(); openMatTableDialog(${idx})"
                                style="background:#4caf50;color:white;border:none;padding:3px 8px;border-radius:3px;cursor:pointer;font-size:10px;">
                            MAT
                        </button>
                        <input type="number" value="${item.count}" min="0" style="width:45px;"
                               onclick="event.stopPropagation();"
                               onchange="changeBomQty(${idx}, parseInt(this.value))">
                        <button class="btn btn-sm" style="background:#dc3545;color:white;border:none;" onclick="event.stopPropagation(); removeBomItem(${idx})">âœ•</button>
                    </div>
                </div>`;
            });

            container.innerHTML = html;
        }

        function buildMatOptionsForSize(size, currentMat) {
            let html = '';

            // Normalize size for comparison (e.g., "1613" -> "16", "13" -> "13")
            const normalizedBomSize = normalizeSize(size);

            // Filter by normalized size
            const matchingMats = normalizedBomSize ?
                TEST_CUTTER_MATS.filter(m => normalizeSize(m.size) === normalizedBomSize) :
                TEST_CUTTER_MATS;

            if (matchingMats.length > 0) {
                html += `<optgroup label="Size ${normalizedBomSize}mm (${matchingMats.length} options)">`;
                matchingMats.forEach(m => {
                    const selected = m.mat === currentMat ? 'selected' : '';
                    html += `<option value='${JSON.stringify(m)}' ${selected}>${m.type} - ${m.mat} (${m.chamfer})</option>`;
                });
                html += `</optgroup>`;
            }

            // Add option for manual entry
            html += `<option value="manual">Enter manually...</option>`;

            return html;
        }

        function buildSameSizeCutterOptions(bomIdx) {
            // Build checkbox options for all OTHER BOM items with the same normalized size
            // User can select which cutters to REPLACE with the current item
            const bomItem = currentData.summary[bomIdx];
            if (!bomItem) return '';

            const targetSize = normalizeSize(bomItem.size);
            if (!targetSize) return '';

            // Find all OTHER BOM items with the same normalized size (exclude current)
            const sameSizeItems = [];
            currentData.summary.forEach((item, idx) => {
                if (normalizeSize(item.size) === targetSize && idx !== bomIdx) {
                    sameSizeItems.push({ item, idx });
                }
            });

            if (sameSizeItems.length === 0) {
                return ''; // No other items with same size to replace
            }

            let html = `<div class="fill-options-group" style="background:#f3e5f5;border-radius:4px;padding:5px;max-height:150px;overflow-y:auto;">
                <div class="fill-options-group-label" style="color:#7b1fa2;">
                    Replace Cutters with #${bomItem.index} (${targetSize}mm - ${sameSizeItems.length} available):
                </div>
                <div style="font-size:9px;color:#666;margin-bottom:5px;">Select cutters whose locations will be replaced by this item</div>`;

            sameSizeItems.forEach(({ item, idx }) => {
                const colorIdx = (idx % BOM_COLORS.length) + 1;
                const familyInfo = item.family_number ? ` | ${item.family_number}` : '';
                const clCount = countCuttersForBomIndex(item.index);

                html += `
                <label class="fill-checkbox-label" style="display:block;padding:4px 2px;border-bottom:1px solid #e1bee7;">
                    <input type="checkbox" name="replaceCutter${bomIdx}" value="${idx}" data-bom="${bomIdx}">
                    <span class="bom-color-${colorIdx}" style="display:inline-block;width:18px;height:18px;border-radius:50%;text-align:center;line-height:18px;font-size:10px;margin-right:4px;">${item.index}</span>
                    <span style="font-family:monospace;font-size:10px;">${item.size}</span> |
                    <span style="color:#2e7d32;font-size:10px;">${item.type}</span> |
                    <span style="color:#1565c0;font-size:10px;">${item.mat_number}</span>${familyInfo}
                    <span style="color:#888;font-size:9px;margin-left:4px;">(${clCount} in CL)</span>
                </label>`;
            });

            // Add "Select All" option
            html += `
                <div style="margin-top:5px;padding-top:5px;border-top:2px solid #ce93d8;">
                    <label class="fill-checkbox-label" style="color:#7b1fa2;font-weight:bold;">
                        <input type="checkbox" id="selectAllReplace${bomIdx}" onchange="toggleSelectAllReplace(${bomIdx}, this.checked)">
                        Select All (${sameSizeItems.length})
                    </label>
                </div>`;

            html += `</div>`;
            return html;
        }

        function toggleSelectAllReplace(bomIdx, checked) {
            const checkboxes = document.querySelectorAll(`input[name="replaceCutter${bomIdx}"]`);
            checkboxes.forEach(cb => cb.checked = checked);
        }

        function applyMatChange(bomIdx, value) {
            if (!value) return;

            const bomItem = currentData.summary[bomIdx];
            if (!bomItem) return;

            // Save to history before making changes
            saveToHistory();

            if (value === 'manual') {
                const newMat = prompt('Enter MAT number:', bomItem.mat_number);
                if (newMat && newMat.trim()) {
                    bomItem.mat_number = newMat.trim();
                    renderEditLayout();
                    renderBomTable();
                }
                return;
            }

            try {
                const mat = JSON.parse(value);
                bomItem.mat_number = mat.mat;
                bomItem.type = mat.type;
                bomItem.chamfer = mat.chamfer;
                bomItem.family_number = mat.family;

                // Update all cutters in CL that have this BOM index
                updateCuttersForBomItem(bomItem);

                renderEditLayout();
                renderBomTable();
                updateStats();
            } catch (e) {
                console.error('Error applying MAT change:', e);
            }
        }

        function renderEditCL() {
            const container = document.getElementById('editClContent');
            if (!currentData || !currentData.blades) {
                container.innerHTML = '<p style="color:#999;">No blade data</p>';
                return;
            }

            let html = '';
            currentData.blades.forEach((blade, bladeIdx) => {
                html += `<div class="blade-block" style="margin-bottom:10px;">
                    <div class="blade-inner">
                        <div class="blade-label">${blade.name}</div>
                        <div class="blade-rows-wrap">`;

                ['r1', 'r2', 'r3', 'r4'].forEach(rowKey => {
                    if (hasRowData(blade[rowKey])) {
                        html += renderEditBladeRow(blade[rowKey], bladeIdx, rowKey);
                    }
                });

                html += `</div></div></div>`;
            });

            container.innerHTML = html;
        }

        function renderEditBladeRow(rowData, bladeIdx, rowKey) {
            const rowLabel = rowKey.toUpperCase();

            // Get selected BOM item size for size-mismatch highlighting
            let selectedSize = null;
            if (editState.selectedBomIndex !== null && currentData.summary) {
                const selectedBom = currentData.summary[editState.selectedBomIndex];
                if (selectedBom) {
                    selectedSize = normalizeSize(selectedBom.size);
                }
            }

            let rowHtml = '';

            const positionsOrder = ['CONE', 'NOSE', 'SHOULDER', 'GAUGE', 'PAD'];
            positionsOrder.forEach(pos => {
                const cells = (rowData && rowData[pos]) || [];
                if (cells.length > 0) {
                    let positionHtml = '';

                    cells.forEach((c, ci) => {
                        const bomIdx = c.group || 0;
                        const isUnassigned = bomIdx === 0;
                        const colorClass = isUnassigned ? 'bom-item-unassigned' : `bom-item-${bomIdx}`;
                        const bomItem = currentData.summary ? currentData.summary.find(b => b.index === bomIdx) : null;
                        const cutterSize = bomItem ? normalizeSize(bomItem.size) : normalizeSize(c.size || c.originalSize || '');

                        // Check if this cutter's size matches selected BOM item
                        let availableClass = isUnassigned ? 'unassigned' : '';
                        if (selectedSize && cutterSize && selectedSize !== cutterSize) {
                            availableClass = 'invalid-size';
                        }

                        const dataAttrs = `data-blade="${bladeIdx}" data-row="${rowKey}" data-pos="${pos}" data-idx="${ci}" data-size="${cutterSize}"`;
                        const displayIdx = isUnassigned ? '?' : bomIdx;
                        const displayType = isUnassigned ? '(unassigned)' : (c.type || '');

                        positionHtml += `<div class="cutter edit-cutter ${availableClass}" onclick="clickEditCutter(${bladeIdx},'${rowKey}','${pos}',${ci})" ${dataAttrs}>
                            <div class="cutter-type">${displayType}</div>
                            <div class="cutter-circle ${colorClass}">${displayIdx}</div>
                            <div class="cutter-chamfer">${c.chamfer || ''}</div>
                        </div>`;
                    });

                    rowHtml += `<div class="pos-label" style="border-left:3px solid ${POS_COLORS[pos]};">${pos}</div>`;
                    rowHtml += positionHtml;
                }
            });

            let html = `<div class="blade-row">
                <div class="row-label">${rowLabel}</div>
                <div class="positions-wrap">${rowHtml}</div>
            </div>`;

            return html;
        }

        function selectBomItem(idx) {
            if (editState.mode === 'review') return;
            editState.selectedBomIndex = (editState.selectedBomIndex === idx) ? null : idx;
            renderEditLayout();
        }

        function updateClDrivenModeIndicator() {
            const indicator = document.getElementById('clDrivenModeIndicator');
            const status = document.getElementById('clDrivenModeStatus');

            // Always show the indicator
            indicator.style.display = 'inline-block';
            if (editState.clDrivenMode) {
                indicator.className = 'cl-mode-indicator active';
                status.textContent = 'ON';
            } else {
                indicator.className = 'cl-mode-indicator inactive';
                status.textContent = 'OFF';
            }
        }

        function toggleClDrivenMode() {
            editState.clDrivenMode = !editState.clDrivenMode;
            updateClDrivenModeIndicator();
            console.log('CL-Driven mode:', editState.clDrivenMode ? 'ON' : 'OFF');
        }

        function updateBomFoldIndicator() {
            const indicator = document.getElementById('bomFoldIndicator');
            const status = document.getElementById('bomFoldStatus');
            if (!indicator || !status) return;

            if (editState.bomFolded) {
                indicator.className = 'bom-fold-indicator active';
                status.textContent = 'ON';
            } else {
                indicator.className = 'bom-fold-indicator inactive';
                status.textContent = 'OFF';
            }
        }

        function toggleBomFold() {
            editState.bomFolded = !editState.bomFolded;
            updateBomFoldIndicator();
            renderEditBom(); // Re-render BOM list with fold applied
            console.log('BOM Fold:', editState.bomFolded ? 'ON' : 'OFF');
        }

        function clickEditCutter(bladeIdx, rowKey, pos, cutterIdx) {
            if (editState.mode === 'review') return;
            if (editState.selectedBomIndex === null) {
                alert('Please select a BOM item first');
                return;
            }

            const selectedBom = currentData.summary[editState.selectedBomIndex];
            const cutter = currentData.blades[bladeIdx][rowKey][pos][cutterIdx];
            const oldBomIndex = cutter.group;

            // Check size compatibility using normalized sizes
            const oldBomItem = currentData.summary.find(b => b.index === oldBomIndex);
            const cutterSize = oldBomItem ? normalizeSize(oldBomItem.size) : normalizeSize(cutter.size || '');
            const selectedSize = normalizeSize(selectedBom.size);

            if (cutterSize && cutterSize !== selectedSize) {
                alert(`Size mismatch! This pocket is ${cutterSize}mm, but selected item is ${selectedSize}mm`);
                return;
            }

            // If cutter is already assigned to this BOM item, do nothing
            if (oldBomIndex === selectedBom.index) {
                return;
            }

            // Calculate what CL count will be after assignment
            const currentCLCount = countCuttersForBomIndex(selectedBom.index);
            const newCLCount = currentCLCount + 1;

            // Check if we need CL-driven mode (only when CL would exceed BOM)
            if (newCLCount > selectedBom.count) {
                // CL count will exceed BOM count after this assignment
                if (!editState.clDrivenMode) {
                    // Ask if user wants to enable CL-driven mode
                    const enableCLDriven = confirm(
                        `CL quantity (${newCLCount}) will exceed BOM quantity (${selectedBom.count}) for this item.\n\n` +
                        'Enable CL-Driven mode to automatically increase BOM quantity?\n\n' +
                        'â€¢ YES = Enable CL-Driven and proceed with assignment\n' +
                        'â€¢ NO = Cancel this assignment'
                    );
                    if (enableCLDriven) {
                        editState.clDrivenMode = true;
                        updateClDrivenModeIndicator();
                    } else {
                        // User cancelled - don't make the assignment
                        return;
                    }
                }
            }

            // Save to history before making changes
            saveToHistory();

            // Handle BOM quantity updates based on CL-driven mode
            if (editState.clDrivenMode) {
                // Only increase BOM if CL will exceed it
                if (newCLCount > selectedBom.count) {
                    selectedBom.count = newCLCount;
                }
                // Decrease old BOM item count if it was assigned
                if (oldBomItem && oldBomItem.count > 0) {
                    // Only decrease if CL count for old item is less than BOM count
                    const oldCLCount = countCuttersForBomIndex(oldBomItem.index);
                    if (oldCLCount <= oldBomItem.count) {
                        oldBomItem.count--;
                    }
                }
            }

            // Assign the cutter to selected BOM item
            cutter.group = selectedBom.index;
            cutter.type = selectedBom.type;
            cutter.chamfer = selectedBom.chamfer;

            renderEditLayout();
            renderBomTable();
            renderFullPage();
            updateStats();
        }

        function countCuttersForBomIndex(bomIndex) {
            let count = 0;
            if (!currentData || !currentData.blades) return 0;

            currentData.blades.forEach(blade => {
                ['r1', 'r2', 'r3', 'r4'].forEach(rowKey => {
                    if (blade[rowKey]) {
                        Object.values(blade[rowKey]).forEach(cells => {
                            cells.forEach(cell => {
                                if (cell.group === bomIndex) count++;
                            });
                        });
                    }
                });
            });
            return count;
        }

        // ========== FILL PANEL FUNCTIONS ==========
        let openFillPanelIdx = null;

        function toggleFillPanel(bomIdx) {
            const panel = document.getElementById(`fillPanel${bomIdx}`);
            if (!panel) return;

            // Close any other open panels
            document.querySelectorAll('.fill-options-panel.show').forEach(p => {
                if (p.id !== `fillPanel${bomIdx}`) {
                    p.classList.remove('show');
                }
            });

            // Toggle this panel
            panel.classList.toggle('show');
            openFillPanelIdx = panel.classList.contains('show') ? bomIdx : null;

            // Add click handler to close panel when clicking outside
            if (panel.classList.contains('show')) {
                setTimeout(() => {
                    document.addEventListener('click', closeFillPanelOnOutsideClick);
                }, 100);
            }
        }

        function closeFillPanelOnOutsideClick(e) {
            if (openFillPanelIdx === null) return;
            const panel = document.getElementById(`fillPanel${openFillPanelIdx}`);
            if (panel && !panel.contains(e.target) && !e.target.closest('.fill-options-panel')) {
                panel.classList.remove('show');
                openFillPanelIdx = null;
                document.removeEventListener('click', closeFillPanelOnOutsideClick);
            }
        }

        function applyFillOptions(bomIdx) {
            if (editState.mode === 'review') return;

            const bomItem = currentData.summary[bomIdx];
            if (!bomItem) return;

            // Get all checked checkboxes for this BOM item
            const panel = document.getElementById(`fillPanel${bomIdx}`);
            if (!panel) return;

            // Get selected cutters to REPLACE (checkboxes)
            const replaceCutterCheckboxes = panel.querySelectorAll(`input[name="replaceCutter${bomIdx}"]:checked`);
            const cuttersToReplace = [];
            replaceCutterCheckboxes.forEach(cb => {
                const targetIdx = parseInt(cb.value);
                const targetItem = currentData.summary[targetIdx];
                if (targetItem) {
                    cuttersToReplace.push({ idx: targetIdx, index: targetItem.index });
                }
            });

            const checked = panel.querySelectorAll('input[type="checkbox"]:checked');

            // Save to history before making changes
            saveToHistory();

            // Collect selected positions, rows, and special options
            const selectedPositions = [];
            const selectedRows = [];
            let originalLocationsOnly = false;

            checked.forEach(cb => {
                const val = cb.value;
                const name = cb.name || '';
                // Skip the replaceCutter checkboxes and selectAll checkbox
                if (name.startsWith('replaceCutter') || cb.id?.startsWith('selectAllReplace')) return;

                if (val === 'original_locations_only') {
                    originalLocationsOnly = true;
                } else if (['cone_only', 'nose_only', 'shoulder_only', 'gauge_only', 'pad_only'].includes(val)) {
                    selectedPositions.push(val.replace('_only', '').toUpperCase());
                } else if (['r1_only', 'r2_only', 'r3_only', 'r4_only'].includes(val)) {
                    selectedRows.push(val.replace('_only', ''));
                }
            });

            // Get cutter selection mode (radio buttons)
            const cutterSelectRadio = panel.querySelector(`input[name="cutterSelect${bomIdx}"]:checked`);
            const cutterSelection = cutterSelectRadio ? cutterSelectRadio.value : 'all_cutters';

            // Get distribution mode (radio buttons)
            const distModeRadio = panel.querySelector(`input[name="distMode${bomIdx}"]:checked`);
            const distributionMode = distModeRadio ? distModeRadio.value : 'sequential';

            let totalAssigned = 0;

            if (cuttersToReplace.length > 0) {
                // REPLACE MODE: Replace selected cutters' locations with current item
                totalAssigned = applyReplaceFill(bomIdx, cuttersToReplace, selectedPositions, selectedRows, cutterSelection, distributionMode);
            } else {
                // NORMAL MODE: Fill same-size locations with current item
                totalAssigned = applyFilteredFill(bomIdx, selectedPositions, selectedRows, originalLocationsOnly, cutterSelection, distributionMode);
            }

            // Close panel and refresh
            panel.classList.remove('show');
            openFillPanelIdx = null;

            // Uncheck all checkboxes
            panel.querySelectorAll('input[type="checkbox"]:checked').forEach(cb => cb.checked = false);

            renderEditLayout();
            renderBomTable();
            renderFullPage();
            updateStats();

            // Show feedback
            if (totalAssigned > 0) {
                if (cuttersToReplace.length > 0) {
                    const replacedIndices = cuttersToReplace.map(c => '#' + c.index).join(', ');
                    console.log(`Replaced ${totalAssigned} cutters from [${replacedIndices}] with BOM item #${bomItem.index}`);
                } else {
                    console.log(`Assigned ${totalAssigned} cutters to BOM item #${bomItem.index}`);
                }
            } else {
                const extraInfo = originalLocationsOnly ? ' in original replaced locations' : '';
                const replaceInfo = cuttersToReplace.length > 0 ? ' from selected cutters' : '';
                alert(`No matching locations found${replaceInfo}${extraInfo} with selected filters.`);
            }
        }

        function applyReplaceFill(bomIdx, cuttersToReplace, positions, rows, cutterSelection, distributionMode) {
            // Replace locations of selected cutters with the current BOM item
            const bomItem = currentData.summary[bomIdx];
            if (!bomItem) return 0;

            const positionsToUse = positions.length > 0 ? positions : ['CONE', 'NOSE', 'SHOULDER', 'GAUGE', 'PAD'];
            const rowsToUse = rows.length > 0 ? rows : ['r1', 'r2', 'r3', 'r4'];

            // Get the BOM indices to replace
            const indicesToReplace = cuttersToReplace.map(c => currentData.summary[c.idx].index);

            let assigned = 0;

            // Go through all blades and rows
            currentData.blades.forEach(blade => {
                rowsToUse.forEach(rowKey => {
                    if (!blade[rowKey]) return;

                    positionsToUse.forEach(pos => {
                        const cells = blade[rowKey][pos];
                        if (!cells) return;

                        // Get eligible indices based on cutter selection mode
                        const eligibleIndices = getReplacementEligibleIndices(cells, indicesToReplace, cutterSelection);

                        eligibleIndices.forEach(cellIdx => {
                            const cell = cells[cellIdx];
                            // Replace this cell with the new BOM item
                            cell.group = bomItem.index;
                            cell.type = bomItem.type;
                            cell.chamfer = bomItem.chamfer;
                            assigned++;
                        });
                    });
                });
            });

            return assigned;
        }

        function getReplacementEligibleIndices(cells, indicesToReplace, cutterMode) {
            // Find cells that belong to the cutters being replaced
            const eligibleCells = [];
            cells.forEach((cell, idx) => {
                if (indicesToReplace.includes(cell.group)) {
                    eligibleCells.push({ cell, idx });
                }
            });

            if (eligibleCells.length === 0) return [];

            // Apply cutter selection logic
            switch (cutterMode) {
                case 'first_cutter':
                    return eligibleCells.slice(0, 1).map(e => e.idx);
                case 'first_two':
                    return eligibleCells.slice(0, 2).map(e => e.idx);
                case 'last_cutter':
                    return eligibleCells.slice(-1).map(e => e.idx);
                case 'last_two':
                    return eligibleCells.slice(-2).map(e => e.idx);
                case 'second_to_last':
                    if (eligibleCells.length >= 2) {
                        return [eligibleCells[eligibleCells.length - 2].idx];
                    }
                    return [];
                case 'all_cutters':
                default:
                    return eligibleCells.map(e => e.idx);
            }
        }

        function applyFilteredFill(bomIdx, positions, rows, originalLocationsOnly = false, cutterSelection = 'all_cutters', distributionMode = 'sequential') {
            const bomItem = currentData.summary[bomIdx];
            if (!bomItem) return 0;

            const bladeOrder = getBladeOrder(currentData.blades.length);
            const positionsToUse = positions.length > 0 ? positions : ['CONE', 'NOSE', 'SHOULDER', 'GAUGE', 'PAD'];
            const rowsToUse = rows.length > 0 ? rows : ['r1', 'r2', 'r3', 'r4'];

            // Get list of original indices this item replaces (if any)
            const replacedOriginalIndices = [];
            if (originalLocationsOnly && bomItem.replacesOriginal && bomItem.replacesOriginal.length > 0) {
                bomItem.replacesOriginal.forEach(r => {
                    if (r.originalIndex !== undefined) {
                        replacedOriginalIndices.push(r.originalIndex);
                    }
                });
            }

            const targetQty = bomItem.count;
            const bomSize = normalizeSize(bomItem.size);

            // Helper function to check if a cell can be filled
            function canFillCell(cell) {
                // If originalLocationsOnly is enabled, only fill cells that were originally assigned
                if (originalLocationsOnly && replacedOriginalIndices.length > 0) {
                    if (!replacedOriginalIndices.includes(cell.originalGroup)) {
                        return false;
                    }
                }
                // Check size match
                const cellBomItem = currentData.summary.find(b => b.index === cell.group);
                const cellSize = cell.originalSize || (cellBomItem ? normalizeSize(cellBomItem.size) : '');
                return cellSize && cellSize === bomSize && cell.group !== bomItem.index;
            }

            // Helper function to get eligible cell indices based on cutter selection mode
            function getEligibleIndices(cells, cutterMode) {
                // First, filter cells that match criteria
                const eligibleCells = [];
                cells.forEach((cell, idx) => {
                    if (canFillCell(cell)) {
                        eligibleCells.push({ cell, idx });
                    }
                });

                if (eligibleCells.length === 0) return [];

                // Apply cutter selection logic
                switch (cutterMode) {
                    case 'first_cutter':
                        return eligibleCells.slice(0, 1).map(e => e.idx);
                    case 'first_two':
                        return eligibleCells.slice(0, 2).map(e => e.idx);
                    case 'last_cutter':
                        return eligibleCells.slice(-1).map(e => e.idx);
                    case 'last_two':
                        return eligibleCells.slice(-2).map(e => e.idx);
                    case 'second_to_last':
                        if (eligibleCells.length >= 2) {
                            return [eligibleCells[eligibleCells.length - 2].idx];
                        }
                        return []; // Not enough cutters for "second to last"
                    case 'all_cutters':
                    default:
                        return eligibleCells.map(e => e.idx);
                }
            }

            // Helper function to fill a cell
            function fillCell(cell) {
                cell.group = bomItem.index;
                cell.type = bomItem.type;
                cell.chamfer = bomItem.chamfer;
            }

            let assigned = 0;

            if (distributionMode === 'round_robin') {
                // ROUND-ROBIN MODE: Fill one cutter per row, then cycle back until quantity is met
                // Build list of all fillable slots: [{bladeIdx, rowKey, pos, cellIdx, cell}]
                const allSlots = [];

                for (const bladeIdx of bladeOrder) {
                    const blade = currentData.blades[bladeIdx];
                    for (const rowKey of rowsToUse) {
                        if (!blade[rowKey]) continue;

                        for (const pos of positionsToUse) {
                            const cells = blade[rowKey][pos] || [];
                            const eligibleIndices = getEligibleIndices(cells, cutterSelection);

                            eligibleIndices.forEach(cellIdx => {
                                allSlots.push({
                                    bladeIdx,
                                    rowKey,
                                    pos,
                                    cellIdx,
                                    cell: cells[cellIdx]
                                });
                            });
                        }
                    }
                }

                // Group slots by blade+row for round-robin
                const rowGroups = {};
                allSlots.forEach(slot => {
                    const key = `${slot.bladeIdx}_${slot.rowKey}`;
                    if (!rowGroups[key]) {
                        rowGroups[key] = [];
                    }
                    rowGroups[key].push(slot);
                });

                // Get ordered row keys based on blade order
                const orderedRowKeys = [];
                for (const bladeIdx of bladeOrder) {
                    for (const rowKey of rowsToUse) {
                        const key = `${bladeIdx}_${rowKey}`;
                        if (rowGroups[key] && rowGroups[key].length > 0) {
                            orderedRowKeys.push(key);
                        }
                    }
                }

                // Track current index within each row group
                const rowIndices = {};
                orderedRowKeys.forEach(key => rowIndices[key] = 0);

                // Round-robin: take one from each row, cycle back
                let rowPointer = 0;
                let cyclesWithoutProgress = 0;

                while (assigned < targetQty && cyclesWithoutProgress < orderedRowKeys.length) {
                    const currentRowKey = orderedRowKeys[rowPointer];
                    const rowSlots = rowGroups[currentRowKey];
                    const currentIdx = rowIndices[currentRowKey];

                    if (currentIdx < rowSlots.length) {
                        const slot = rowSlots[currentIdx];
                        if (slot.cell.group !== bomItem.index) { // Not already assigned
                            fillCell(slot.cell);
                            assigned++;
                        }
                        rowIndices[currentRowKey]++;
                        cyclesWithoutProgress = 0;
                    } else {
                        cyclesWithoutProgress++;
                    }

                    // Move to next row
                    rowPointer = (rowPointer + 1) % orderedRowKeys.length;

                    // Prevent infinite loop
                    if (assigned >= allSlots.length) break;
                }
            } else {
                // SEQUENTIAL MODE: Fill each row fully before moving to next
                outerLoop:
                for (const bladeIdx of bladeOrder) {
                    const blade = currentData.blades[bladeIdx];
                    for (const rowKey of rowsToUse) {
                        if (!blade[rowKey]) continue;

                        for (const pos of positionsToUse) {
                            const cells = blade[rowKey][pos] || [];
                            const eligibleIndices = getEligibleIndices(cells, cutterSelection);

                            for (const cellIdx of eligibleIndices) {
                                const cell = cells[cellIdx];
                                fillCell(cell);
                                assigned++;

                                if (assigned >= targetQty) break outerLoop;
                            }
                        }
                    }
                }
            }

            return assigned;
        }

        function handleDistribution(bomIdx, option) {
            // Legacy function - kept for compatibility
            if (!option || editState.mode === 'review') return;

            const bomItem = currentData.summary[bomIdx];
            if (!bomItem) return;

            // Save to history before making changes
            saveToHistory();

            let assigned = 0;

            if (option === 'clear') {
                // Clear all assignments for this BOM item
                clearBomAssignments(bomItem.index);
            } else if (['cone_only', 'nose_only', 'shoulder_only', 'gauge_only', 'pad_only'].includes(option)) {
                // Position-specific fill: fill ONLY that position across all blades/rows
                const posName = option.replace('_only', '').toUpperCase();
                assigned = autoFillPositionOnly(bomIdx, posName);
            } else if (['r1_only', 'r2_only', 'r3_only', 'r4_only'].includes(option)) {
                // Row-specific fill: fill all positions in just that row
                const rowKey = option.replace('_only', '');
                assigned = autoFillRowOnly(bomIdx, rowKey);
            } else {
                // Auto-fill starting from specified position (goes through all positions)
                assigned = autoFillFromPosition(bomIdx, option.toUpperCase());
            }

            renderEditLayout();
        }

        function clearBomAssignments(bomIndex) {
            // This clears the type/chamfer but keeps the group (index) -
            // Actually per requirements we should NOT change the location/size
            // So we'll just unassign by setting to a "vacant" state
            // For now, let's just log - the user clicks to assign
            console.log('Clear assignments for index:', bomIndex);
        }

        function autoFillFromPosition(bomIdx, startPos, maxToAssign = null) {
            const bomItem = currentData.summary[bomIdx];
            if (!bomItem) return 0;

            const positionsOrder = ['CONE', 'NOSE', 'SHOULDER', 'GAUGE', 'PAD'];
            const startPosIdx = positionsOrder.indexOf(startPos);
            if (startPosIdx === -1) return 0;

            // Get ordered positions starting from selected
            const orderedPositions = [...positionsOrder.slice(startPosIdx), ...positionsOrder.slice(0, startPosIdx)];

            // Get blade order: B1, B(last), B(last-1), ..., B2
            const bladeOrder = getBladeOrder(currentData.blades.length);

            let assigned = 0;
            const targetQty = maxToAssign !== null ? maxToAssign : bomItem.count;

            // Iterate through blades in order - no blocking, just fill matching cells
            outerLoop:
            for (const bladeIdx of bladeOrder) {
                const blade = currentData.blades[bladeIdx];
                // For each blade, go through rows R1, R2, R3, R4
                for (const rowKey of ['r1', 'r2', 'r3', 'r4']) {
                    if (!blade[rowKey]) continue;

                    // Go through positions in order
                    for (const pos of orderedPositions) {
                        const cells = blade[rowKey][pos] || [];
                        for (let ci = 0; ci < cells.length; ci++) {
                            const cell = cells[ci];

                            // Check if this cell matches the size
                            // Use originalSize (stored on data load) as primary
                            const cellBomItem = currentData.summary.find(b => b.index === cell.group);
                            const cellSize = cell.originalSize || (cellBomItem ? normalizeSize(cellBomItem.size) : '');
                            const bomSize = normalizeSize(bomItem.size);

                            if (cellSize && cellSize === bomSize && cell.group !== bomItem.index) {
                                // Assign this cutter
                                cell.group = bomItem.index;
                                cell.type = bomItem.type;
                                cell.chamfer = bomItem.chamfer;
                                assigned++;

                                if (assigned >= targetQty) break outerLoop;
                            }
                        }
                    }
                }
            }

            return assigned;
        }

        function autoFillRowOnly(bomIdx, rowKey, maxToAssign = null) {
            const bomItem = currentData.summary[bomIdx];
            if (!bomItem) return 0;

            const positionsOrder = ['CONE', 'NOSE', 'SHOULDER', 'GAUGE', 'PAD'];

            // Get blade order: B1, B(last), B(last-1), ..., B2
            const bladeOrder = getBladeOrder(currentData.blades.length);

            let assigned = 0;
            const targetQty = maxToAssign !== null ? maxToAssign : bomItem.count;

            // Iterate through blades in order, but only process the specified row - no blocking
            outerLoop:
            for (const bladeIdx of bladeOrder) {
                const blade = currentData.blades[bladeIdx];
                if (!blade[rowKey]) continue;

                // Go through positions in order
                for (const pos of positionsOrder) {
                    const cells = blade[rowKey][pos] || [];
                    for (let ci = 0; ci < cells.length; ci++) {
                        const cell = cells[ci];

                        // Check if this cell matches the size
                        // Use originalSize (stored on data load) as primary
                        const cellBomItem = currentData.summary.find(b => b.index === cell.group);
                        const cellSize = cell.originalSize || (cellBomItem ? normalizeSize(cellBomItem.size) : '');
                        const bomSize = normalizeSize(bomItem.size);

                        if (cellSize && cellSize === bomSize && cell.group !== bomItem.index) {
                            // Assign this cutter
                            cell.group = bomItem.index;
                            cell.type = bomItem.type;
                            cell.chamfer = bomItem.chamfer;
                            assigned++;

                            if (assigned >= targetQty) break outerLoop;
                        }
                    }
                }
            }

            return assigned;
        }

        function autoFillPositionOnly(bomIdx, posName, maxToAssign = null) {
            // Fill ONLY the specified position (e.g., CONE only, NOSE only)
            const bomItem = currentData.summary[bomIdx];
            if (!bomItem) return 0;

            // Get blade order: B1, B(last), B(last-1), ..., B2
            const bladeOrder = getBladeOrder(currentData.blades.length);

            let assigned = 0;
            const targetQty = maxToAssign !== null ? maxToAssign : bomItem.count;

            // Iterate through blades in order, checking ONLY the specified position - no blocking
            outerLoop:
            for (const bladeIdx of bladeOrder) {
                const blade = currentData.blades[bladeIdx];
                // For each blade, go through rows R1, R2, R3, R4
                for (const rowKey of ['r1', 'r2', 'r3', 'r4']) {
                    if (!blade[rowKey]) continue;

                    // Only process the specified position
                    const cells = blade[rowKey][posName] || [];
                    for (let ci = 0; ci < cells.length; ci++) {
                        const cell = cells[ci];

                        // Check if this cell matches the size
                        // Use originalSize (stored on data load) as primary
                        const cellBomItem = currentData.summary.find(b => b.index === cell.group);
                        const cellSize = cell.originalSize || (cellBomItem ? normalizeSize(cellBomItem.size) : '');
                        const bomSize = normalizeSize(bomItem.size);

                        if (cellSize && cellSize === bomSize && cell.group !== bomItem.index) {
                            // Assign this cutter
                            cell.group = bomItem.index;
                            cell.type = bomItem.type;
                            cell.chamfer = bomItem.chamfer;
                            assigned++;

                            if (assigned >= targetQty) break outerLoop;
                        }
                    }
                }
            }

            return assigned;
        }

        function changeBomQty(bomIdx, newQty) {
            const bomItem = currentData.summary[bomIdx];
            if (!bomItem) return;

            // Save to history before making changes
            saveToHistory();

            const oldQty = bomItem.count;
            const clCount = countCuttersForBomIndex(bomItem.index);

            if (newQty < oldQty) {
                // Quantity reduced
                const diff = oldQty - newQty;
                document.getElementById('splitDialogMsg').innerHTML =
                    `You reduced quantity from ${oldQty} to ${newQty} (${diff} fewer).<br><br>` +
                    `Do you want to add a new BOM item for the ${diff} removed cutters?`;

                editState.splitCallback = (addNew) => {
                    bomItem.count = newQty;
                    if (addNew) {
                        // Pass the source BOM item so we can track replacement
                        addNewBomItemWithQty(diff, bomItem.size, bomItem);
                    }
                    renderEditLayout();
                };

                document.getElementById('splitDialog').classList.remove('hidden');
            } else {
                bomItem.count = newQty;
                renderEditLayout();
            }
        }

        function closeSplitDialog(addNew) {
            document.getElementById('splitDialog').classList.add('hidden');
            if (editState.splitCallback) {
                editState.splitCallback(addNew);
                editState.splitCallback = null;
            }
        }

        // Delete BOM Dialog state
        let deleteBomState = {
            idx: null,
            item: null,
            cutterCount: 0,
            callback: null,
            source: null  // 'merged' or 'edit'
        };

        function showDeleteBomDialog(idx, item, cutterCount, source, callback) {
            deleteBomState = { idx, item, cutterCount, callback, source };

            const msg = `Remove "${item.type || item.mat_number}" (Index: ${item.index})?`;
            document.getElementById('deleteBomDialogMsg').innerHTML =
                `<strong>${msg}</strong><br><br>This item has <strong>${cutterCount}</strong> cutter(s) in the Cutter Layout.`;

            document.getElementById('deleteBomDialog').classList.remove('hidden');
        }

        function closeDeleteBomDialog() {
            document.getElementById('deleteBomDialog').classList.add('hidden');
            deleteBomState = { idx: null, item: null, cutterCount: 0, callback: null, source: null };
        }

        function confirmDeleteBom(action) {
            // Save callback before closing (which resets state)
            const callback = deleteBomState.callback;
            closeDeleteBomDialog();
            if (callback) {
                callback(action);
            }
        }

        function addNewBomItemWithQty(qty, size, sourceBomItem = null) {
            if (!currentData.summary) currentData.summary = [];

            const newIndex = currentData.summary.length + 1;

            // Build replacement info
            let replacesOriginal = [];
            if (sourceBomItem) {
                replacesOriginal.push({
                    mat_number: sourceBomItem.mat_number,
                    type: sourceBomItem.type,
                    originalIndex: sourceBomItem.index
                });
            }

            currentData.summary.push({
                index: newIndex,
                size: size,
                chamfer: '',
                type: '',
                count: qty,
                mat_number: 'NEW-' + newIndex,
                family_number: '',
                replacesOriginal: replacesOriginal,  // Track what original item(s) this replaces
                _isNewItem: true // Flag: this is a newly added item, not from original PDF
            });
        }

        function removeBomItem(bomIdx) {
            const bomItem = currentData.summary[bomIdx];
            if (!bomItem) return;

            const cutterCount = countCuttersForBomIndex(bomItem.index);

            // If no cutters in CL, just confirm and remove
            if (cutterCount === 0) {
                if (confirm(`Remove item ${bomItem.index} (${bomItem.mat_number})?`)) {
                    executeRemoveBomItem(bomIdx, bomItem, 'remove');
                }
                return;
            }

            // Show dialog with options for handling cutters
            showDeleteBomDialog(bomIdx, bomItem, cutterCount, 'edit', (action) => {
                executeRemoveBomItem(bomIdx, bomItem, action);
            });
        }

        // Execute the actual removal from Edit Layout
        function executeRemoveBomItem(bomIdx, bomItem, action) {
            // Save to history before making changes
            saveToHistory();

            const removedIndex = bomItem.index;

            if (action === 'placeholder') {
                // Mark cutters as placeholders
                currentData.blades.forEach(blade => {
                    ['r1', 'r2', 'r3', 'r4'].forEach(rowKey => {
                        if (blade[rowKey]) {
                            Object.values(blade[rowKey]).forEach(cells => {
                                cells.forEach(cell => {
                                    if (cell.group === removedIndex) {
                                        cell.group = null;
                                        cell.type = '';
                                        cell.chamfer = '';
                                        cell._isPlaceholder = true;
                                    }
                                });
                            });
                        }
                    });
                });
            } else if (action === 'remove') {
                // Completely remove cutters from CL
                currentData.blades.forEach(blade => {
                    ['r1', 'r2', 'r3', 'r4'].forEach(rowKey => {
                        if (blade[rowKey]) {
                            Object.keys(blade[rowKey]).forEach(pos => {
                                blade[rowKey][pos] = blade[rowKey][pos].filter(cell => cell.group !== removedIndex);
                            });
                        }
                    });
                });
            }

            // Remove from BOM
            currentData.summary.splice(bomIdx, 1);

            // Re-index BOM items and update CL references
            const indexMapping = {}; // old index -> new index
            currentData.summary.forEach((item, i) => {
                const oldIndex = item.index;
                const newIndex = i + 1;
                indexMapping[oldIndex] = newIndex;
                item.index = newIndex;
            });

            // Update cutter group references to match new BOM indices
            currentData.blades.forEach(blade => {
                ['r1', 'r2', 'r3', 'r4'].forEach(rowKey => {
                    if (blade[rowKey]) {
                        Object.values(blade[rowKey]).forEach(cells => {
                            cells.forEach(cell => {
                                if (cell.group > 0 && indexMapping[cell.group] !== undefined) {
                                    cell.group = indexMapping[cell.group];
                                }
                            });
                        });
                    }
                });
            });

            // Update cutter_shapes to match new indices
            if (currentData.cutter_shapes) {
                const newShapes = {};
                Object.keys(currentData.cutter_shapes).forEach(oldKey => {
                    const oldIndex = parseInt(oldKey) || oldKey;
                    const newIndex = indexMapping[oldIndex] || indexMapping[String(oldIndex)];
                    if (newIndex !== undefined) {
                        newShapes[String(newIndex)] = currentData.cutter_shapes[oldKey];
                    }
                });
                currentData.cutter_shapes = newShapes;
            }

            // Clear selection if removed item was selected
            if (editState.selectedBomIndex === bomIdx) {
                editState.selectedBomIndex = null;
            } else if (editState.selectedBomIndex > bomIdx) {
                editState.selectedBomIndex--;
            }

            renderEditLayout();
            renderBomTable();
            renderFullPage();
            updateStats();
        }

        function addNewBomItem() {
            // Open the MAT Table Dialog in 'add' mode (no size lock, all cutters available)
            openMatTableDialogForNewItem();
        }

        function openMatTableDialogForNewItem() {
            matTableState.mode = 'add';
            matTableState.bomIdx = null;
            matTableState.lockedSize = null;
            matTableState.sizeLocked = false; // Show ALL sizes for new item
            matTableState.selectedMat = null;

            console.log('MAT Dialog - Add New Item mode (all sizes available)');

            // Update size info display - show that all sizes are available
            document.getElementById('matTableSizeInfo').textContent = `Size: ALL (select any)`;
            document.getElementById('matTableSizeInfo').style.background = '#e8f5e9';
            document.getElementById('matTableSizeInfo').style.color = '#2e7d32';
            document.getElementById('matTableUnlockBtn').textContent = 'Lock Size';

            // Disable apply button until selection
            document.getElementById('matTableApplyBtn').disabled = true;
            document.getElementById('matTableSelected').textContent = 'Click a row to select';

            // Update BOM info subtitle for add mode
            document.getElementById('matTableBomInfo').textContent = `Adding New BOM Item`;

            // Show ALL cutters (no size filter)
            const tableData = TEST_CUTTER_MATS;

            console.log('MAT Dialog - Showing all items:', tableData.length);

            // Initialize or update Tabulator
            if (matTableState.tabulator) {
                matTableState.tabulator.destroy();
            }

            matTableState.tabulator = new Tabulator("#matTabulatorTable", {
                data: tableData,
                height: "380px",
                layout: "fitColumns",
                selectable: 1,
                selectableRangeMode: "click",
                placeholder: "<div style='padding:30px;color:#999;'>No matching cutters found</div>",
                initialSort: [{ column: "type", dir: "asc" }],
                columns: getMatTableColumns()
            });

            // Tabulator 5.x: Register events using .on() method
            matTableState.tabulator.on("rowClick", function(e, row) {
                matTableState.tabulator.deselectRow();
                row.select();

                const selected = row.getData();
                matTableState.selectedMat = selected;

                // Show selection with stock status
                let stockInfo = selected.qty > 0 ? `(${selected.qty} in stock)` : 'âš ï¸ OUT OF STOCK';
                document.getElementById('matTableSelected').textContent =
                    `Selected: ${selected.mat} - ${selected.type} (${selected.size}) ${stockInfo}`;

                const applyBtn = document.getElementById('matTableApplyBtn');
                applyBtn.disabled = false;
                applyBtn.removeAttribute('disabled');
                applyBtn.style.background = '#4caf50';
                applyBtn.style.cursor = 'pointer';
                applyBtn.style.opacity = '1';
            });

            matTableState.tabulator.on("dataFiltered", function(filters, rows) {
                document.getElementById('matTableCount').textContent = `${rows.length} items`;

                if (matTableState.selectedMat) {
                    const stillVisible = rows.some(r => r.getData().mat === matTableState.selectedMat.mat);
                    if (!stillVisible) {
                        matTableState.selectedMat = null;
                        document.getElementById('matTableSelected').textContent = 'Click a row to select';
                        document.getElementById('matTableApplyBtn').disabled = true;
                        document.getElementById('matTableApplyBtn').style.background = '#9e9e9e';
                    }
                }
            });

            matTableState.tabulator.on("dataLoaded", function(data) {
                document.getElementById('matTableCount').textContent = `${data.length} items`;
            });

            matTableState.tabulator.on("tableBuilt", function() {
                const table = matTableState.tabulator;
                if (table) {
                    const count = table.getData().length;
                    document.getElementById('matTableCount').textContent = `${count} items`;
                }
            });

            // Show dialog
            document.getElementById('matTableDialog').classList.remove('hidden');
            document.getElementById('matTableCount').textContent = `${tableData.length} items`;
        }

        // Old dialog functions removed - using inline dropdowns now

        function updateCuttersForBomItem(bomItem) {
            // Update all cutters in CL that reference this BOM item's index
            if (!currentData || !currentData.blades) return;

            currentData.blades.forEach(blade => {
                ['r1', 'r2', 'r3', 'r4'].forEach(rowKey => {
                    if (blade[rowKey]) {
                        Object.values(blade[rowKey]).forEach(cells => {
                            cells.forEach(cell => {
                                if (cell.group === bomItem.index) {
                                    cell.type = bomItem.type;
                                    cell.chamfer = bomItem.chamfer;
                                }
                            });
                        });
                    }
                });
            });
        }

        function renderEditValidation() {
            const container = document.getElementById('editValidationItems');
            if (!currentData || !currentData.summary) {
                container.innerHTML = '<span style="color:#666;">No data</span>';
                return;
            }

            // Group by size and check quantities
            const sizeMap = {};
            currentData.summary.forEach(item => {
                if (!sizeMap[item.size]) sizeMap[item.size] = { bom: 0, cl: 0 };
                sizeMap[item.size].bom += item.count;
            });

            // Count CL by size
            currentData.blades.forEach(blade => {
                ['r1', 'r2', 'r3', 'r4'].forEach(rowKey => {
                    if (blade[rowKey]) {
                        Object.values(blade[rowKey]).forEach(cells => {
                            cells.forEach(cell => {
                                const bomItem = currentData.summary.find(b => b.index === cell.group);
                                const size = bomItem ? bomItem.size : cell.size || 'Unknown';
                                if (!sizeMap[size]) sizeMap[size] = { bom: 0, cl: 0 };
                                sizeMap[size].cl++;
                            });
                        });
                    }
                });
            });

            let html = '';
            let hasErrors = false;

            for (const [size, counts] of Object.entries(sizeMap)) {
                const isValid = counts.bom === counts.cl;
                if (!isValid) hasErrors = true;
                html += `<div class="validation-item ${isValid ? 'valid' : 'invalid'}">
                    ${size}: ${counts.bom} BOM / ${counts.cl} CL ${isValid ? 'âœ“' : 'âœ—'}
                </div>`;
            }

            container.innerHTML = html;
            const validationDiv = document.getElementById('editValidation');
            if (hasErrors) {
                validationDiv.classList.add('has-errors');
            } else {
                validationDiv.classList.remove('has-errors');
            }
        }

        // MAT Dialog functions
        function showMatDialog() {
            document.getElementById('matDialogOriginal').textContent = currentData.header.mat_number || '';
            document.getElementById('matDialogInput').value = editState.newMatSuffix || 'M';
            document.getElementById('matDialogSN').value = editState.newSerialNumber || '';
            document.getElementById('matDialogNoSuffix').checked = false;
            document.getElementById('matDialog').classList.remove('hidden');
        }

        function closeMatDialog() {
            document.getElementById('matDialog').classList.add('hidden');
            // Restore the save button onclick to default
            document.querySelector('#matDialog .btn-green').setAttribute('onclick', 'saveMatDialog()');
        }

        function saveMatDialog() {
            editState.newMatSuffix = document.getElementById('matDialogInput').value;

            // Get original values for comparison
            const originalMat = originalData?.header?.mat_number || currentData.header.mat_number || '';
            const originalSn = originalData?.header?.sn_number || '0';

            // Check if SN was changed
            let snWasChanged = false;
            if (document.getElementById('matDialogAddSN').checked) {
                editState.newSerialNumber = document.getElementById('matDialogSN').value;
                document.getElementById('snNumber').value = editState.newSerialNumber;
                // SN is changed if it's different from original and not empty/zero
                snWasChanged = editState.newSerialNumber &&
                               editState.newSerialNumber !== '' &&
                               editState.newSerialNumber !== '0' &&
                               editState.newSerialNumber !== originalSn;
            }

            // Check if suffix was added (any non-empty suffix counts as a change)
            const suffixWasAdded = editState.newMatSuffix && editState.newMatSuffix !== '';

            // Check if correction mode (no suffix) is enabled
            const noSuffixMode = document.getElementById('matDialogNoSuffix').checked;

            // Only mark as explicitly set if actual changes were made OR correction mode enabled
            editState.matIdExplicitlySet = suffixWasAdded || snWasChanged || noSuffixMode;

            // Update the MAT number (use original mat number as base)
            const newMat = originalMat + editState.newMatSuffix;
            document.getElementById('matNumber').value = newMat;
            currentData.header.mat_number = newMat;
            currentData.original_filename = newMat;

            // Update date_created to current date/time for modified BOM (only if changes were made)
            if (editState.matIdExplicitlySet) {
                const dateStr = formatDateWithTime();
                document.getElementById('dateCreated').value = dateStr;
                currentData.header.date_created = dateStr;
            }

            closeMatDialog();
            renderEditLayout();
            // Also refresh Full Page view if it's visible
            if (document.getElementById('tab-fullpage').style.display !== 'none') {
                renderFullPage();
            }
        }

        // ========== MAT TABLE DIALOG (Tabulator) ==========
        let matTableState = {
            bomIdx: null,
            lockedSize: null,
            sizeLocked: true,
            selectedMat: null,
            tabulator: null,
            mode: 'edit' // 'edit' for existing BOM item, 'add' for new item
        };

        function getMatBomIndex(matNumber) {
            // Check if a MAT number is in the current BOM and return its index
            if (!currentData || !currentData.summary) return null;
            const bomItem = currentData.summary.find(item => item.mat_number === matNumber);
            return bomItem ? bomItem.index : null;
        }

        function getMatTableColumns() {
            // Build columns with "In BOM" indicator
            return [
                {
                    title: "BOM",
                    field: "mat",
                    width: 50,
                    hozAlign: "center",
                    headerSort: true,
                    headerFilter: "select",
                    headerFilterParams: { values: {"": "All", "inbom": "In BOM", "notinbom": "Not in BOM"} },
                    headerFilterPlaceholder: "All",
                    headerFilterFunc: function(headerValue, rowValue) {
                        if (!headerValue || headerValue === "") return true;
                        const bomIdx = getMatBomIndex(rowValue);
                        if (headerValue === "inbom") return bomIdx !== null;
                        if (headerValue === "notinbom") return bomIdx === null;
                        return true;
                    },
                    formatter: function(cell) {
                        const matNum = cell.getValue();
                        const bomIdx = getMatBomIndex(matNum);
                        if (bomIdx !== null) {
                            const colorIdx = ((bomIdx - 1) % BOM_COLORS.length) + 1;
                            return `<span class="bom-color-${colorIdx}" style="display:inline-block;width:20px;height:20px;border-radius:50%;text-align:center;line-height:20px;font-size:10px;font-weight:bold;">${bomIdx}</span>`;
                        }
                        return "<span style='color:#ccc;'>-</span>";
                    },
                    sorter: function(a, b) {
                        const aIdx = getMatBomIndex(a) || 999;
                        const bIdx = getMatBomIndex(b) || 999;
                        return aIdx - bIdx;
                    }
                },
                {
                    title: "MAT #",
                    field: "mat",
                    width: 100,
                    headerFilter: "input",
                    headerFilterPlaceholder: "Search MAT...",
                    formatter: function(cell) {
                        const matNum = cell.getValue();
                        const bomIdx = getMatBomIndex(matNum);
                        const inBomStyle = bomIdx !== null ? "background:#e8f5e9;" : "";
                        return `<span style='font-family:monospace;font-weight:bold;color:#1565c0;${inBomStyle}'>${matNum}</span>`;
                    }
                },
                {
                    title: "Size",
                    field: "size",
                    width: 70,
                    hozAlign: "center",
                    headerFilter: matTableState.sizeLocked ? false : "select",
                    headerFilterParams: { valuesLookup: "active", sortValuesList: "asc" },
                    headerFilterPlaceholder: "All",
                    formatter: function(cell) {
                        const val = cell.getValue();
                        return "<span style='background:#e3f2fd;padding:2px 6px;border-radius:10px;font-size:11px;font-family:monospace;'>" + val + "</span>";
                    }
                },
                {
                    title: "Type",
                    field: "type",
                    width: 90,
                    headerFilter: "select",
                    headerFilterParams: { valuesLookup: "active", sortValuesList: "asc" },
                    headerFilterPlaceholder: "All Types",
                    formatter: function(cell) {
                        return "<span style='color:#2e7d32;font-weight:600;'>" + cell.getValue() + "</span>";
                    }
                },
                {
                    title: "Chamfer",
                    field: "chamfer",
                    width: 100,
                    headerFilter: "select",
                    headerFilterParams: { valuesLookup: "active", sortValuesList: "asc" },
                    headerFilterPlaceholder: "All Chamfers"
                },
                {
                    title: "Family",
                    field: "family",
                    width: 80,
                    headerFilter: "select",
                    headerFilterParams: { valuesLookup: "active", sortValuesList: "asc" },
                    headerFilterPlaceholder: "All",
                    formatter: function(cell) {
                        const val = cell.getValue();
                        return val ? "<span style='color:#666;'>" + val + "</span>" : "<span style='color:#ccc;'>-</span>";
                    }
                },
                {
                    title: "Stock",
                    field: "qty",
                    width: 70,
                    hozAlign: "center",
                    headerFilter: "select",
                    headerFilterParams: { values: {"": "All", "instock": "In Stock", "out": "Out of Stock"} },
                    headerFilterPlaceholder: "Stock",
                    headerFilterFunc: function(headerValue, rowValue) {
                        if (!headerValue || headerValue === "") return true;
                        if (headerValue === "instock") return rowValue > 0;
                        if (headerValue === "out") return rowValue === 0;
                        return true;
                    },
                    formatter: function(cell) {
                        const val = cell.getValue();
                        if (val > 0) {
                            const color = val > 50 ? '#4caf50' : (val > 10 ? '#ff9800' : '#f44336');
                            return "<span style='font-weight:600;color:" + color + ";'>" + val + "</span>";
                        } else {
                            return "<span style='background:#ffebee;color:#c62828;padding:2px 6px;border-radius:4px;font-size:10px;font-weight:600;'>OUT</span>";
                        }
                    }
                }
            ];
        }

        function openMatTableDialog(bomIdx) {
            const bomItem = currentData.summary[bomIdx];
            if (!bomItem) return;

            matTableState.mode = 'edit';
            matTableState.bomIdx = bomIdx;
            // Store the EXACT original size for locked filtering (e.g., "1613" stays "1613")
            matTableState.lockedSize = bomItem.size;
            matTableState.sizeLocked = true;
            matTableState.selectedMat = null;

            // Debug: log sizes for troubleshooting
            console.log('MAT Dialog - BOM size (exact):', bomItem.size);

            // Update size info display - show exact size (only this specific size code)
            document.getElementById('matTableSizeInfo').textContent = `Size: ${bomItem.size} (locked)`;
            document.getElementById('matTableSizeInfo').style.background = '#fff3e0';
            document.getElementById('matTableSizeInfo').style.color = '#e65100';
            document.getElementById('matTableUnlockBtn').textContent = 'Unlock Size';

            // Disable apply button until selection
            document.getElementById('matTableApplyBtn').disabled = true;
            document.getElementById('matTableSelected').textContent = 'Click a row to select';

            // Update BOM info subtitle
            document.getElementById('matTableBomInfo').textContent = `Updating BOM Item #${bomItem.index} - ${bomItem.type || 'Unknown Type'}`;

            // Filter data by EXACT size when locked (e.g., "1613" only matches "1613", not "1608" or "16")
            const tableData = matTableState.sizeLocked
                ? TEST_CUTTER_MATS.filter(m => m.size === matTableState.lockedSize)
                : TEST_CUTTER_MATS;

            console.log('MAT Dialog - Filtered items:', tableData.length, 'matching exact size', matTableState.lockedSize);

            // Initialize or update Tabulator
            if (matTableState.tabulator) {
                matTableState.tabulator.destroy();
            }

            matTableState.tabulator = new Tabulator("#matTabulatorTable", {
                data: tableData,
                height: "380px",
                layout: "fitColumns",
                selectable: 1,
                selectableRangeMode: "click",
                placeholder: "<div style='padding:30px;color:#999;'>No matching cutters found</div>",
                initialSort: [{ column: "type", dir: "asc" }],
                columns: getMatTableColumns()
            });

            // Tabulator 5.x: Register events using .on() method
            matTableState.tabulator.on("rowClick", function(e, row) {
                // Select this row
                matTableState.tabulator.deselectRow();
                row.select();

                // Update state and UI
                const selected = row.getData();
                matTableState.selectedMat = selected;

                // Show selection with stock status
                let stockInfo = selected.qty > 0 ? `(${selected.qty} in stock)` : 'âš ï¸ OUT OF STOCK';
                document.getElementById('matTableSelected').textContent =
                    `Selected: ${selected.mat} - ${selected.type} (${selected.size}) ${stockInfo}`;

                // Enable Apply button
                const applyBtn = document.getElementById('matTableApplyBtn');
                applyBtn.disabled = false;
                applyBtn.removeAttribute('disabled');
                applyBtn.style.background = '#4caf50';
                applyBtn.style.cursor = 'pointer';
                applyBtn.style.opacity = '1';
            });

            matTableState.tabulator.on("dataFiltered", function(filters, rows) {
                document.getElementById('matTableCount').textContent = `${rows.length} items`;

                // Clear selection when filters change (row might be filtered out)
                if (matTableState.selectedMat) {
                    const stillVisible = rows.some(r => r.getData().mat === matTableState.selectedMat.mat);
                    if (!stillVisible) {
                        matTableState.selectedMat = null;
                        document.getElementById('matTableSelected').textContent = 'Click a row to select';
                        document.getElementById('matTableApplyBtn').disabled = true;
                        document.getElementById('matTableApplyBtn').style.background = '#9e9e9e';
                    }
                }
            });

            matTableState.tabulator.on("dataLoaded", function(data) {
                document.getElementById('matTableCount').textContent = `${data.length} items`;
            });

            matTableState.tabulator.on("tableBuilt", function() {
                // Update count after table is fully built
                const table = matTableState.tabulator;
                if (table) {
                    const count = table.getData().length;
                    document.getElementById('matTableCount').textContent = `${count} items`;
                }
            });

            // Show dialog
            document.getElementById('matTableDialog').classList.remove('hidden');

            // Immediately update count
            document.getElementById('matTableCount').textContent = `${tableData.length} items`;
        }

        function closeMatTableDialog() {
            document.getElementById('matTableDialog').classList.add('hidden');
            matTableState.bomIdx = null;
            matTableState.selectedMat = null;
            // Reset mode and context
            document.getElementById('matTableMode').value = 'bom';
            window.addCutterContext = null;
            // Reset title
            const titleEl = document.querySelector('.mat-table-title');
            if (titleEl) titleEl.textContent = 'Select Cutter MAT';
        }

        function toggleMatSizeLock() {
            if (matTableState.sizeLocked) {
                // Ask for confirmation before unlocking
                const confirmed = confirm(
                    'Changing cutter size may affect bit compatibility.\n\n' +
                    'Are you sure you want to unlock size filtering?'
                );
                if (!confirmed) return;

                matTableState.sizeLocked = false;
                document.getElementById('matTableSizeInfo').textContent = `âš ï¸ Size: ALL`;
                document.getElementById('matTableSizeInfo').style.background = 'rgba(255,82,82,0.3)';
                document.getElementById('matTableSizeInfo').style.color = 'white';
                document.getElementById('matTableUnlockBtn').textContent = 'ðŸ”’ Lock';

                // Reload table with all data - valuesLookup:"active" handles dropdown updates
                if (matTableState.tabulator) {
                    matTableState.tabulator.setData(TEST_CUTTER_MATS);
                    // Re-add size header filter as dropdown
                    matTableState.tabulator.updateColumnDefinition("size", {
                        headerFilter: "select",
                        headerFilterParams: { valuesLookup: "active", sortValuesList: "asc" }
                    });
                }
            } else {
                matTableState.sizeLocked = true;
                document.getElementById('matTableSizeInfo').textContent = `Size: ${matTableState.lockedSize} (locked)`;
                document.getElementById('matTableSizeInfo').style.background = '#fff3e0';
                document.getElementById('matTableSizeInfo').style.color = '#e65100';
                document.getElementById('matTableUnlockBtn').textContent = 'Unlock Size';

                // Reload table with filtered data by EXACT size
                if (matTableState.tabulator) {
                    const exactSize = matTableState.lockedSize;
                    const filteredData = TEST_CUTTER_MATS.filter(m => m.size === exactSize);
                    console.log('Re-locking - Filtered items:', filteredData.length, 'matching exact size', exactSize);
                    matTableState.tabulator.setData(filteredData);
                    // Remove size header filter when locked
                    matTableState.tabulator.updateColumnDefinition("size", {headerFilter: false});
                }
            }
        }

        function clearMatFilters() {
            if (matTableState.tabulator) {
                matTableState.tabulator.clearHeaderFilter();
            }
        }

        function applyMatTableSelection() {
            if (!matTableState.selectedMat) return;

            const mat = matTableState.selectedMat;
            const dialogMode = document.getElementById('matTableMode').value;

            // Save to history before changes
            saveToHistory();

            // Handle 'cutter' mode - adding cutter to blade from Blade Editor
            if (dialogMode === 'cutter' && window.addCutterContext) {
                const ctx = window.addCutterContext;
                const { bladeIdx, rowKey, pos, insertIdx } = ctx;

                // Find or create BOM entry for this cutter
                let bomIndex = getMatBomIndex(mat.mat);

                if (bomIndex === null) {
                    // Create new BOM entry
                    if (!currentData.summary) currentData.summary = [];
                    bomIndex = currentData.summary.length + 1;

                    currentData.summary.push({
                        index: bomIndex,
                        size: mat.size,
                        chamfer: mat.chamfer,
                        type: mat.type,
                        count: 0,
                        mat_number: mat.mat,
                        family_number: mat.family || '',
                        replacesOriginal: [],
                        stock_qty: mat.qty,
                        _isNewItem: true // Flag: this is a newly added item, not from original PDF
                    });
                    showMessage(`Added new BOM item: ${mat.type} (Index ${bomIndex})`, 'success');
                }

                // Create the new cutter cell
                const newCutter = {
                    bom_index: bomIndex,
                    size: parseFloat(mat.size) || 0,
                    type: mat.type,
                    group: bomIndex, // Group matches BOM index
                    chamfer: mat.chamfer || '',
                    _isNew: true
                };

                // Get the row and position array
                const blade = currentData.blades[bladeIdx];
                if (!blade[rowKey]) blade[rowKey] = {};
                if (!blade[rowKey][pos]) blade[rowKey][pos] = [];

                // Insert at specified position
                blade[rowKey][pos].splice(insertIdx, 0, newCutter);

                // Update BOM count for this item
                const bomItem = currentData.summary.find(b => b.index === bomIndex);
                if (bomItem) {
                    bomItem.count = countCuttersForBomIndex(bomIndex);
                }

                // Clean up context
                window.addCutterContext = null;
                document.getElementById('matTableMode').value = 'bom';

                // Close dialog and refresh
                closeMatTableDialog();
                renderBladesEditor();
                renderBomTable();
                updateStats();

                showMessage(`Added ${mat.type} to ${blade.name} ${rowKey.toUpperCase()}`, 'success');
                return;
            }

            if (matTableState.mode === 'add') {
                // ADD NEW ITEM MODE
                if (!currentData.summary) currentData.summary = [];

                const newIndex = currentData.summary.length + 1;

                // Show stock warning if out of stock
                if (mat.qty === 0) {
                    const proceed = confirm(
                        `âš ï¸ WARNING: "${mat.type}" (${mat.mat}) is OUT OF STOCK!\n\n` +
                        'Do you still want to add this item?'
                    );
                    if (!proceed) return;
                }

                // Create new BOM item
                // Mark as new item (not from original PDF) to avoid Orig Qty lookup confusion
                currentData.summary.push({
                    index: newIndex,
                    size: mat.size,
                    chamfer: mat.chamfer,
                    type: mat.type,
                    count: 0,
                    mat_number: mat.mat,
                    family_number: mat.family || '',
                    replacesOriginal: [],
                    stock_qty: mat.qty, // Track stock quantity
                    _isNewItem: true // Flag: this is a newly added item, not from original PDF
                });

                console.log('Added new BOM item:', mat.mat, mat.type, mat.size);

            } else {
                // EDIT EXISTING ITEM MODE
                if (matTableState.bomIdx === null) return;

                const bomItem = currentData.summary[matTableState.bomIdx];
                if (!bomItem) return;

                // Check if size is changing
                const newSize = normalizeSize(mat.size);
                const currentSize = normalizeSize(bomItem.size);

                if (newSize !== currentSize) {
                    const confirmed = confirm(
                        `Warning: You are changing the cutter size from ${currentSize}mm to ${newSize}mm.\n\n` +
                        'This may affect bit compatibility. Continue?'
                    );
                    if (!confirmed) return;
                }

                // Show stock warning if out of stock
                if (mat.qty === 0) {
                    const proceed = confirm(
                        `âš ï¸ WARNING: "${mat.type}" (${mat.mat}) is OUT OF STOCK!\n\n` +
                        'Do you still want to use this item?'
                    );
                    if (!proceed) return;
                }

                // Apply the selection
                bomItem.mat_number = mat.mat;
                bomItem.type = mat.type;
                bomItem.chamfer = mat.chamfer;
                bomItem.family_number = mat.family || '';
                bomItem.size = mat.size;
                bomItem.stock_qty = mat.qty; // Track stock quantity

                // Update all cutters in CL that have this BOM index
                updateCuttersForBomItem(bomItem);

                console.log('Updated BOM item:', bomItem.index, mat.mat, mat.type);
            }

            // Close dialog and refresh
            closeMatTableDialog();
            renderEditLayout();
            renderBomTable();
            updateStats();
        }

        function renderBladePreview(blade) {
            // Only render rows that have data (dynamic R1-R4)
            let rowsHtml = '';
            if (hasRowData(blade.r1)) {
                rowsHtml += renderBladeRow(blade.r1, 0, 'r1', 'R1', false);
            }
            if (hasRowData(blade.r2)) {
                rowsHtml += renderBladeRow(blade.r2, 0, 'r2', 'R2', false);
            }
            if (hasRowData(blade.r3)) {
                rowsHtml += renderBladeRow(blade.r3, 0, 'r3', 'R3', false);
            }
            if (hasRowData(blade.r4)) {
                rowsHtml += renderBladeRow(blade.r4, 0, 'r4', 'R4', false);
            }

            if (!rowsHtml) return ''; // No rows with data

            let html = `<div class="blade-block">
                <div class="blade-inner">
                    <div class="blade-label">${blade.name}</div>
                    <div class="blade-rows-wrap">
                        ${rowsHtml}
                    </div>
                </div>
            </div>`;
            return html;
        }
        
        function collectFormData() {
            // ALWAYS use currentData for exports - it contains all modifications
            // The view toggle (Original/Modified) is only for display, not exports
            if (!currentData) {
                console.error('No data loaded');
                return null;
            }
            return {
                header: {
                    sn_number: document.getElementById('snNumber').value,
                    mat_number: document.getElementById('matNumber').value,
                    date_created: document.getElementById('dateCreated').value,
                    revision_level: document.getElementById('revisionLevel').value,
                    software_version: document.getElementById('softwareVersion').value
                },
                summary: currentData.summary || [],
                groups: currentData.groups || [],
                blades: currentData.blades || [],
                original_filename: currentData.original_filename || '',
                // CRITICAL: Include images for PDF/PPT generation
                images: currentData.images || {},
                has_group_legend: currentData.has_group_legend || false,
                group_format: currentData.group_format || 'comma'
            };
        }
        
        function hasActualDataChanges() {
            // Check if there are actual changes to BOM or blades compared to original
            if (!originalData || !currentData) return false;

            // Compare BOM summary
            const origSummary = JSON.stringify(originalData.summary || []);
            const currSummary = JSON.stringify(currentData.summary || []);
            if (origSummary !== currSummary) return true;

            // Compare blades
            const origBlades = JSON.stringify(originalData.blades || []);
            const currBlades = JSON.stringify(currentData.blades || []);
            if (origBlades !== currBlades) return true;

            return false;
        }

        // Validation before PDF generation
        let validationCallback = null;
        let lastValidationResult = null;

        function updateValidationStatus(result) {
            const status = document.getElementById('validationStatus');
            if (!status) return;

            if (!result) {
                status.innerHTML = '';
                status.style.background = '';
                return;
            }

            lastValidationResult = result;

            if (result.messages && result.messages.length > 0) {
                status.innerHTML = 'âš ï¸ ' + result.messages.length + ' warning(s)';
                status.style.background = '#fff3cd';
                status.style.color = '#856404';
                status.title = 'Click to see details';
            } else {
                status.innerHTML = 'âœ“ Valid';
                status.style.background = '#d4edda';
                status.style.color = '#155724';
                status.title = 'No issues detected';
            }
        }

        function clearValidationStatus() {
            const status = document.getElementById('validationStatus');
            if (status) {
                status.innerHTML = 'â—‹ Not validated';
                status.style.background = '#e9ecef';
                status.style.color = '#6c757d';
                status.title = 'Click to validate';
            }
            lastValidationResult = null;
        }

        function runValidationCheck() {
            if (!currentData) return;

            // If we have cached warnings, show them in dialog
            if (lastValidationResult && lastValidationResult.messages && lastValidationResult.messages.length > 0) {
                showValidationDialog(lastValidationResult.messages, null);
                return;
            }

            // Build form data for validation
            const formData = {
                summary: currentData.summary || [],
                blades: currentData.blades || []
            };

            fetch('/cutter-map/validate/', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-CSRFToken': getCSRFToken()
                },
                body: JSON.stringify(formData)
            })
            .then(r => r.json())
            .then(result => {
                updateValidationStatus(result);
                if (result.messages && result.messages.length > 0) {
                    showValidationDialog(result.messages, null);
                } else {
                    showMsg('Validation passed - no issues detected', 'success');
                }
            })
            .catch(err => {
                console.error('Validation error:', err);
                showMsg('Validation check failed', 'error');
            });
        }

        function validateBeforeGenerate(formData, onSuccess) {
            showMsg('Validating data...', 'success');

            fetch('/cutter-map/validate/', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-CSRFToken': getCSRFToken()
                },
                body: JSON.stringify(formData)
            })
            .then(r => r.json())
            .then(result => {
                console.log('Validation response:', result);
                updateValidationStatus(result); // Update status indicator
                if (result && result.messages && Array.isArray(result.messages) && result.messages.length > 0) {
                    // Show validation warnings
                    showValidationDialog(result.messages, onSuccess);
                } else {
                    // No issues, proceed directly
                    onSuccess();
                }
            })
            .catch(err => {
                console.error('Validation error:', err);
                // On error, proceed anyway with warning
                showMsg('Validation check failed, proceeding...', 'error');
                onSuccess();
            });
        }

        function showValidationDialog(messages, callback) {
            validationCallback = callback;
            console.log('Validation messages:', JSON.stringify(messages));

            const container = document.getElementById('validationMessages');

            if (!messages || messages.length === 0) {
                container.innerHTML = '<div style="color: #666;">No specific issues detected.</div>';
                document.getElementById('validationDialog').classList.remove('hidden');
                return;
            }

            let html = '';
            for (let i = 0; i < messages.length; i++) {
                const msg = messages[i];
                console.log('Message ' + i + ':', JSON.stringify(msg));
                const isError = (msg.type === 'error');
                const icon = isError ? '&#10060;' : '&#9888;';
                const color = isError ? '#dc3545' : '#856404';
                const text = msg.message || msg.code || JSON.stringify(msg);
                html += '<div style="margin-bottom: 8px; padding: 8px; border-left: 3px solid ' + color + '; background: white; color: #333;">';
                html += '<span style="color:' + color + '; margin-right: 5px;">' + icon + '</span>' + text;
                html += '</div>';
            }
            container.innerHTML = html;

            document.getElementById('validationDialog').classList.remove('hidden');
        }

        function closeValidationDialog(proceed) {
            document.getElementById('validationDialog').classList.add('hidden');
            if (proceed && validationCallback) {
                validationCallback();
            }
            validationCallback = null;
        }

        function generatePDF() {
            if (!currentData) {
                showMsg('No data to export. Please upload a PDF first.', 'error');
                return;
            }

            // Check which tab is active
            const activeTab = document.querySelector('.tab.active');
            const activeTabName = activeTab ? activeTab.dataset.tab : 'fullpage';

            // If in Edit Layout or Deep Edit tab, always treat as Modified
            // Otherwise, check Full Page view setting
            const isOriginal = (activeTabName === 'fullpage') && (fullPageView === 'original');

            if (isOriginal) {
                // Generate Original BOM with -Ext suffix
                generateOriginalPDF();
            } else {
                // Modified BOM view - check if there are actual changes
                const hasChanges = hasActualDataChanges();
                const originalMat = originalData?.header?.mat_number || '';
                const currentMat = document.getElementById('matNumber').value || '';
                const matChanged = currentMat && currentMat !== originalMat;
                const sn = document.getElementById('snNumber').value || '';
                const originalSn = originalData?.header?.sn_number || '0';
                const snChanged = sn && sn !== '0' && sn !== '' && sn !== originalSn;

                // If there are data changes but MAT ID was NOT changed, show dialog
                if (hasChanges && !matChanged && !snChanged) {
                    showMatDialogForPDF();
                } else {
                    // No changes, or MAT ID already set - generate directly
                    generateModifiedPDF();
                }
            }
        }

        function showMatDialogForPDF() {
            // Show the Mat dialog and set callback to generate PDF after
            document.getElementById('matDialogOriginal').textContent = originalData?.header?.mat_number || currentData.header.mat_number || '';
            document.getElementById('matDialogInput').value = editState.newMatSuffix || 'M';
            document.getElementById('matDialogSN').value = editState.newSerialNumber || '';
            document.getElementById('matDialogNoSuffix').checked = false;
            document.getElementById('matDialog').classList.remove('hidden');

            // Temporarily override saveMatDialog to generate PDF after
            window.saveMatDialogForPDF = function() {
                editState.newMatSuffix = document.getElementById('matDialogInput').value;
                const originalMat = originalData?.header?.mat_number || currentData.header.mat_number || '';
                const originalSn = originalData?.header?.sn_number || '0';

                // Check if SN was changed
                let snWasChanged = false;
                if (document.getElementById('matDialogAddSN').checked) {
                    editState.newSerialNumber = document.getElementById('matDialogSN').value;
                    document.getElementById('snNumber').value = editState.newSerialNumber;
                    snWasChanged = editState.newSerialNumber &&
                                   editState.newSerialNumber !== '' &&
                                   editState.newSerialNumber !== '0' &&
                                   editState.newSerialNumber !== originalSn;
                }

                // Check if suffix was added
                const suffixWasAdded = editState.newMatSuffix && editState.newMatSuffix !== '';

                // Check if "no suffix" correction mode is enabled
                const noSuffixMode = document.getElementById('matDialogNoSuffix').checked;

                // Require at least one change for modified PDF (unless correction mode)
                if (!suffixWasAdded && !snWasChanged && !noSuffixMode) {
                    showMsg('Please enter a suffix, Serial Number, or enable correction mode.', 'error');
                    return;
                }

                // Mark as explicitly set (we know at least one change was made)
                editState.matIdExplicitlySet = true;

                // Update the MAT number display (use original mat as base)
                const newMat = originalMat + editState.newMatSuffix;
                document.getElementById('matNumber').value = newMat;
                currentData.header.mat_number = newMat;
                currentData.original_filename = newMat;

                // Update date_created to current date/time
                const dateStr = formatDateWithTime();
                document.getElementById('dateCreated').value = dateStr;
                currentData.header.date_created = dateStr;

                closeMatDialog();
                renderEditLayout();
                // Also refresh Full Page view to show updated headers
                if (document.getElementById('tab-fullpage').style.display !== 'none') {
                    renderFullPage();
                }
                generateModifiedPDF();
            };

            // Swap the onclick temporarily
            document.querySelector('#matDialog .btn-green').setAttribute('onclick', 'saveMatDialogForPDF()');
        }

        function generateOriginalPDF() {
            // Use originalData for export
            const formData = {
                header: {
                    sn_number: originalData.header.sn_number || '0',
                    mat_number: originalData.header.mat_number || '',
                    date_created: originalData.header.date_created || '',
                    revision_level: originalData.header.revision_level || '',
                    software_version: originalData.header.software_version || ''
                },
                summary: originalData.summary || [],
                groups: originalData.groups || [],
                blades: originalData.blades || [],
                original_filename: (originalData.header.mat_number || 'output') + '-Ext',
                images: originalData.images || {},
                cutter_shapes: originalData.cutter_shapes || {},
                drill_bit_image: originalData.drill_bit_image || null,
                has_group_legend: originalData.has_group_legend || false,
                group_format: originalData.group_format || 'comma',
                is_original: true
            };

            // Validate before generating
            validateBeforeGenerate(formData, function() {
                showMsg('Generating Original PDF...', 'success');
                fetch('/cutter-map/generate/', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRFToken': getCSRFToken()
                    },
                    body: JSON.stringify(formData)
                })
                .then(r => r.json())
                .then(result => {
                    if (result.success) {
                        showMsg('Original PDF generated!', 'success');
                        window.open(result.download_url, '_blank');
                    } else {
                        console.error('PDF generation error:', result);
                        alert('PDF Error: ' + result.error);
                        showMsg('Error: ' + result.error, 'error');
                    }
                })
                .catch(err => {
                    console.error('PDF generation failed:', err);
                    alert('PDF Error: ' + err.message);
                    showMsg('Error generating PDF: ' + err.message, 'error');
                });
            });
        }

        function generateModifiedPDF() {
            // Build filename by comparing ACTUAL values to original
            const originalMat = originalData?.header?.mat_number || 'output';
            const currentMat = document.getElementById('matNumber').value || '';
            const sn = document.getElementById('snNumber').value || '';
            const originalSn = originalData?.header?.sn_number || '0';

            // Check for ACTUAL changes by comparing values
            // MAT is changed if current mat number is different from original
            const matChanged = currentMat && currentMat !== originalMat;
            // SN is changed only if it's different from original AND not empty/zero
            const snChanged = sn && sn !== '0' && sn !== '' && sn !== originalSn;

            // Check if data has actual modifications (BOM/CL changes)
            const hasDataChanges = hasActualDataChanges();
            // Check if correction mode was explicitly set (matIdExplicitlySet is set by saveMatDialogForPDF)
            const isCorrectionMode = editState.matIdExplicitlySet && !matChanged && !snChanged;

            let filename;
            let dateToUse;
            let snToUse;
            let matToUse;

            if (!matChanged && !snChanged && !hasDataChanges && !isCorrectionMode) {
                // No actual changes - use same filename and original headers
                filename = originalMat + '-Ext';
                dateToUse = originalData?.header?.date_created || '';
                snToUse = originalData?.header?.sn_number || '0';
                matToUse = originalMat;
            } else {
                // Actual changes detected OR correction mode - use modified filename and updated headers
                // Extract suffix: currentMat minus originalMat
                let suffix = '';
                if (matChanged && currentMat.startsWith(originalMat)) {
                    suffix = currentMat.substring(originalMat.length);
                }
                filename = originalMat;
                if (suffix) filename += suffix;
                if (snChanged) filename += '-SN' + sn;
                // For correction mode without suffix, keep original filename
                if (isCorrectionMode && !suffix && !snChanged) {
                    filename = originalMat;
                }

                // Update date to current date for modified PDF (MM/DD/YYYY format)
                const today = new Date();
                const month = String(today.getMonth() + 1).padStart(2, '0');
                const day = String(today.getDate()).padStart(2, '0');
                const year = today.getFullYear();
                dateToUse = `${month}/${day}/${year}`;
                snToUse = snChanged ? sn : (originalData?.header?.sn_number || '0');
                matToUse = matChanged ? currentMat : originalMat;
            }

            const formData = {
                header: {
                    sn_number: snToUse,
                    mat_number: matToUse,
                    date_created: dateToUse,
                    revision_level: document.getElementById('revisionLevel').value,
                    software_version: document.getElementById('softwareVersion').value
                },
                summary: currentData.summary || [],
                groups: currentData.groups || [],
                blades: currentData.blades || [],
                original_filename: filename,
                images: currentData.images || {},
                cutter_shapes: currentData.cutter_shapes || {},
                drill_bit_image: currentData.drill_bit_image || null,
                has_group_legend: currentData.has_group_legend || false,
                group_format: currentData.group_format || 'comma',
                is_original: false
            };

            // Validate before generating
            validateBeforeGenerate(formData, function() {
                showMsg('Generating Modified PDF...', 'success');
                fetch('/cutter-map/generate/', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRFToken': getCSRFToken()
                    },
                    body: JSON.stringify(formData)
                })
                .then(r => r.json())
                .then(result => {
                    if (result.success) {
                        showMsg('Modified PDF generated!', 'success');
                        window.open(result.download_url, '_blank');
                    } else {
                        console.error('PDF generation error:', result);
                        alert('PDF Error: ' + result.error);
                        showMsg('Error: ' + result.error, 'error');
                    }
                })
                .catch(err => {
                    console.error('PDF generation failed:', err);
                    alert('PDF Error: ' + err.message);
                    showMsg('Error generating PDF: ' + err.message, 'error');
                });
            });
        }

        function exportJSON() {
            const formData = collectFormData();
            if (!formData) {
                showMsg('No data to export. Please upload a PDF first.', 'error');
                return;
            }

            fetch('/cutter-map/export-json/', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-CSRFToken': getCSRFToken()
                },
                body: JSON.stringify(formData)
            })
            .then(r => r.json())
            .then(result => {
                if (result.success) {
                    showMsg('JSON exported with your modifications!', 'success');
                    window.open(result.download_url, '_blank');
                }
            })
            .catch(err => {
                showMsg('Error exporting JSON: ' + err.message, 'error');
            });
        }
        
        function resetApp() {
            currentData = null;
            document.getElementById('dataSection').classList.remove('active');
            document.getElementById('uploadSection').classList.remove('hidden');
            document.getElementById('fileInput').value = '';
        }

        // Create BOM from PDF data (when coming from BOM create workflow)
        function createBOMFromPDF() {
            console.log('createBOMFromPDF called');

            const formData = collectFormData();
            console.log('formData:', formData);

            if (!formData) {
                showMsg('No data to create BOM. Please upload a PDF first.', 'error');
                return;
            }

            // Get design context from hidden inputs
            const designIdEl = document.getElementById('designId');
            const designMatEl = document.getElementById('designMat');
            const designId = designIdEl ? designIdEl.value : null;
            const designMat = designMatEl ? designMatEl.value : '';

            console.log('designId:', designId, 'designMat:', designMat);

            if (!designId && !designMat) {
                showMsg('No design context. Please go back to BOM Create and select a design.', 'error');
                return;
            }

            // Build payload for sync-to-erp API
            const payload = {
                design_id: designId || null,
                parent_design_mat: designMat || '',
                document_id: currentData.document_id || null,
                data: {
                    header: formData.header,
                    summary: formData.summary,
                    blades: formData.blades
                },
                create_missing_items: false  // Can be made configurable
            };

            console.log('Sending payload to /cutter-map/api/sync-to-erp/', JSON.stringify(payload, null, 2));

            showMsg('Creating BOM...', 'success');

            fetch('/cutter-map/api/sync-to-erp/', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-CSRFToken': getCSRFToken()
                },
                body: JSON.stringify(payload)
            })
            .then(r => {
                console.log('Response status:', r.status);
                if (!r.ok) {
                    return r.text().then(text => {
                        throw new Error(`HTTP ${r.status}: ${text}`);
                    });
                }
                return r.json();
            })
            .then(result => {
                console.log('API result:', result);
                if (result.success) {
                    showMsg('BOM created successfully! Redirecting to BOM builder...', 'success');
                    // Redirect to BOM builder if we have a BOM ID
                    if (result.bom_id) {
                        setTimeout(() => {
                            window.location.href = `/technology/boms/${result.bom_id}/builder/`;
                        }, 1500);
                    }
                } else {
                    showMsg('Error creating BOM: ' + (result.error || 'Unknown error'), 'error');
                }
            })
            .catch(err => {
                console.error('BOM creation error:', err);
                showMsg('Error creating BOM: ' + err.message, 'error');
            });
        }

        function showMsg(msg, type) {
            const el = document.getElementById('resultMessage');
            el.textContent = msg;
            el.className = 'message ' + type;
            el.classList.remove('hidden');
            // Longer timeout for errors (10s) vs success (4s)
            const timeout = type === 'error' ? 10000 : 4000;
            setTimeout(() => el.classList.add('hidden'), timeout);
        }

        // ========== DESIGN LINK MODAL (Standalone Mode) ==========
        let designLinkData = [];

        function openDesignLinkModal() {
            // Check if we have PDF data first
            if (!currentData) {
                showMsg('Please upload a PDF first before linking to a design.', 'error');
                return;
            }

            document.getElementById('designLinkModal').classList.remove('hidden');
            loadDesignsForLinking();
        }

        function closeDesignLinkModal() {
            document.getElementById('designLinkModal').classList.add('hidden');
        }

        function loadDesignsForLinking() {
            const tbody = document.getElementById('designLinkTableBody');
            tbody.innerHTML = '<tr><td colspan="5" style="padding:20px; text-align:center; color:#999;">Loading...</td></tr>';

            fetch('/technology/api/designs/filter/')
                .then(r => r.json())
                .then(data => {
                    designLinkData = data.designs || [];
                    renderDesignLinkTable(designLinkData);
                })
                .catch(err => {
                    console.error('Error loading designs:', err);
                    tbody.innerHTML = '<tr><td colspan="5" style="padding:20px; text-align:center; color:#c00;">Error loading designs</td></tr>';
                });
        }

        function renderDesignLinkTable(designs) {
            const tbody = document.getElementById('designLinkTableBody');

            if (!designs || designs.length === 0) {
                tbody.innerHTML = '<tr><td colspan="5" style="padding:20px; text-align:center; color:#999;">No designs found. Create one first.</td></tr>';
                return;
            }

            tbody.innerHTML = designs.map(d => `
                <tr style="border-bottom:1px solid #eee;" data-mat="${(d.mat_no || '').toLowerCase()}" data-hdbs="${(d.hdbs_type || '').toLowerCase()}">
                    <td style="padding:8px;">
                        <span style="display:inline-block; padding:2px 6px; border-radius:3px; font-size:10px; font-weight:bold;
                            ${d.order_level === '3' ? 'background:#e3f2fd; color:#1565c0;' : 'background:#e8f5e9; color:#2e7d32;'}">
                            L${d.order_level}
                        </span>
                    </td>
                    <td style="padding:8px; font-family:monospace; font-weight:bold;">${d.mat_no}</td>
                    <td style="padding:8px;">${d.hdbs_type || '-'}</td>
                    <td style="padding:8px;">${d.size || '-'}</td>
                    <td style="padding:8px; text-align:center;">
                        <button onclick="selectDesignForBOM(${d.id}, '${d.mat_no}', '${d.hdbs_type || ''}', '${d.size || ''}')"
                                style="background:#1e3a5f; color:white; border:none; padding:5px 12px; border-radius:4px; cursor:pointer; font-size:11px;">
                            Select
                        </button>
                    </td>
                </tr>
            `).join('');
        }

        function filterDesignLinkTable(searchText) {
            const search = searchText.toLowerCase().trim();
            const rows = document.querySelectorAll('#designLinkTableBody tr[data-mat]');

            rows.forEach(row => {
                const mat = row.dataset.mat || '';
                const hdbs = row.dataset.hdbs || '';
                const matches = !search || mat.includes(search) || hdbs.includes(search);
                row.style.display = matches ? '' : 'none';
            });
        }

        function selectDesignForBOM(designId, designMat, designHdbs, designSize) {
            // Set the design context in hidden inputs
            document.getElementById('designId').value = designId;
            document.getElementById('designMat').value = designMat;
            document.getElementById('designHdbs').value = designHdbs;
            document.getElementById('designSize').value = designSize;

            // Close modal
            closeDesignLinkModal();

            // Show confirmation and create BOM
            showMsg(`Linking to design ${designMat}. Creating BOM...`, 'success');

            // Call the existing createBOMFromPDF function
            setTimeout(() => {
                createBOMFromPDF();
            }, 500);
        }
    </script>
</body>
</html>

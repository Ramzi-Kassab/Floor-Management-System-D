#!/usr/bin/env python3
"""
Database Backup Script (hv - health vault)
Protects SQLite database from accidental loss during git operations.

Usage:
    ./hv           - Create a timestamped backup
    ./hv restore   - List available backups and restore one
    ./hv list      - List all available backups
    ./hv auto      - Create backup only if database changed since last backup
"""

import os
import sys
import shutil
import hashlib
from datetime import datetime
from pathlib import Path

# Configuration
PROJECT_ROOT = Path(__file__).parent.resolve()
DB_FILE = PROJECT_ROOT / "db.sqlite3"
BACKUP_DIR = PROJECT_ROOT / "backups"
MAX_BACKUPS = 10  # Keep last N backups to save disk space

# Colors for terminal output
GREEN = "\033[92m"
YELLOW = "\033[93m"
RED = "\033[91m"
CYAN = "\033[96m"
RESET = "\033[0m"
BOLD = "\033[1m"


def print_status(message, status="info"):
    """Print colored status message."""
    colors = {"ok": GREEN, "warn": YELLOW, "error": RED, "info": CYAN}
    color = colors.get(status, RESET)
    print(f"{color}{message}{RESET}")


def get_file_hash(filepath):
    """Get MD5 hash of a file."""
    if not filepath.exists():
        return None
    hash_md5 = hashlib.md5()
    with open(filepath, "rb") as f:
        for chunk in iter(lambda: f.read(4096), b""):
            hash_md5.update(chunk)
    return hash_md5.hexdigest()


def get_db_size():
    """Get database file size in human readable format."""
    if not DB_FILE.exists():
        return "0 B"
    size = DB_FILE.stat().st_size
    for unit in ["B", "KB", "MB", "GB"]:
        if size < 1024:
            return f"{size:.1f} {unit}"
        size /= 1024
    return f"{size:.1f} TB"


def list_backups():
    """List all available backups."""
    if not BACKUP_DIR.exists():
        return []

    backups = []
    for f in sorted(BACKUP_DIR.glob("db_*.sqlite3"), reverse=True):
        stat = f.stat()
        size_mb = stat.st_size / (1024 * 1024)
        mtime = datetime.fromtimestamp(stat.st_mtime)
        backups.append({
            "path": f,
            "name": f.name,
            "size": f"{size_mb:.2f} MB",
            "date": mtime.strftime("%Y-%m-%d %H:%M:%S"),
            "hash": get_file_hash(f)
        })
    return backups


def create_backup(force=False):
    """Create a new backup of the database."""
    print_status(f"\n{BOLD}=== Database Backup (hv) ==={RESET}", "info")

    # Check if database exists
    if not DB_FILE.exists():
        print_status("No database file found at db.sqlite3", "error")
        return False

    # Check if database is empty
    if DB_FILE.stat().st_size == 0:
        print_status("Database file is empty (0 bytes) - nothing to backup", "warn")
        return False

    # Create backup directory if needed
    BACKUP_DIR.mkdir(exist_ok=True)

    # Check if backup is needed (compare hash with latest backup)
    current_hash = get_file_hash(DB_FILE)
    backups = list_backups()

    if backups and not force:
        latest_hash = backups[0]["hash"]
        if current_hash == latest_hash:
            print_status("Database unchanged since last backup - skipping", "ok")
            print_status(f"  Latest backup: {backups[0]['name']}", "info")
            return True

    # Create timestamped backup
    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    backup_name = f"db_{timestamp}.sqlite3"
    backup_path = BACKUP_DIR / backup_name

    print_status(f"Creating backup: {backup_name}", "info")
    print_status(f"  Source: {DB_FILE} ({get_db_size()})", "info")

    try:
        shutil.copy2(DB_FILE, backup_path)
        print_status(f"Backup created successfully!", "ok")

        # Cleanup old backups
        cleanup_old_backups()

        # Show backup info
        backups = list_backups()
        print_status(f"\n{BOLD}Current backups:{RESET}", "info")
        for i, b in enumerate(backups[:5]):
            marker = " *" if i == 0 else ""
            print_status(f"  {b['name']} ({b['size']}) - {b['date']}{marker}", "ok")

        if len(backups) > 5:
            print_status(f"  ... and {len(backups) - 5} more", "info")

        return True

    except Exception as e:
        print_status(f"Backup failed: {e}", "error")
        return False


def cleanup_old_backups():
    """Remove old backups keeping only MAX_BACKUPS."""
    backups = list_backups()
    if len(backups) > MAX_BACKUPS:
        for b in backups[MAX_BACKUPS:]:
            try:
                b["path"].unlink()
                print_status(f"  Removed old backup: {b['name']}", "warn")
            except Exception as e:
                print_status(f"  Could not remove {b['name']}: {e}", "error")


def restore_backup(backup_name=None):
    """Restore database from a backup."""
    print_status(f"\n{BOLD}=== Restore Database ==={RESET}", "info")

    backups = list_backups()
    if not backups:
        print_status("No backups found!", "error")
        return False

    # If no backup specified, show list and prompt
    if not backup_name:
        print_status("\nAvailable backups:", "info")
        for i, b in enumerate(backups):
            print_status(f"  [{i+1}] {b['name']} ({b['size']}) - {b['date']}", "info")

        print_status(f"\nCurrent database: {get_db_size()}", "warn")

        try:
            choice = input(f"\n{CYAN}Enter backup number to restore (or 'q' to quit): {RESET}")
            if choice.lower() == 'q':
                print_status("Restore cancelled", "warn")
                return False

            idx = int(choice) - 1
            if idx < 0 or idx >= len(backups):
                print_status("Invalid selection", "error")
                return False

            backup_name = backups[idx]["name"]
        except (ValueError, KeyboardInterrupt):
            print_status("\nRestore cancelled", "warn")
            return False

    # Find the backup file
    backup_path = BACKUP_DIR / backup_name
    if not backup_path.exists():
        # Try matching partial name
        matches = [b for b in backups if backup_name in b["name"]]
        if len(matches) == 1:
            backup_path = matches[0]["path"]
        else:
            print_status(f"Backup not found: {backup_name}", "error")
            return False

    # Confirm restore
    print_status(f"\n{BOLD}WARNING: This will replace the current database!{RESET}", "warn")
    print_status(f"  Backup: {backup_path.name}", "info")
    print_status(f"  Current DB size: {get_db_size()}", "info")

    try:
        confirm = input(f"\n{YELLOW}Type 'yes' to confirm restore: {RESET}")
        if confirm.lower() != 'yes':
            print_status("Restore cancelled", "warn")
            return False
    except KeyboardInterrupt:
        print_status("\nRestore cancelled", "warn")
        return False

    # Create a backup of current database before restore
    if DB_FILE.exists() and DB_FILE.stat().st_size > 0:
        pre_restore_backup = BACKUP_DIR / f"db_pre_restore_{datetime.now().strftime('%Y%m%d_%H%M%S')}.sqlite3"
        shutil.copy2(DB_FILE, pre_restore_backup)
        print_status(f"Created pre-restore backup: {pre_restore_backup.name}", "ok")

    # Restore
    try:
        shutil.copy2(backup_path, DB_FILE)
        print_status(f"\nDatabase restored successfully!", "ok")
        print_status(f"  Restored from: {backup_path.name}", "info")
        print_status(f"  New DB size: {get_db_size()}", "info")
        return True
    except Exception as e:
        print_status(f"Restore failed: {e}", "error")
        return False


def show_status():
    """Show current database and backup status."""
    print_status(f"\n{BOLD}=== Database Status ==={RESET}", "info")

    # Current database
    if DB_FILE.exists():
        size = get_db_size()
        mtime = datetime.fromtimestamp(DB_FILE.stat().st_mtime)
        print_status(f"\nCurrent database:", "info")
        print_status(f"  Path: {DB_FILE}", "info")
        print_status(f"  Size: {size}", "ok" if DB_FILE.stat().st_size > 0 else "warn")
        print_status(f"  Modified: {mtime.strftime('%Y-%m-%d %H:%M:%S')}", "info")
    else:
        print_status("\nNo database file found!", "error")

    # Backups
    backups = list_backups()
    print_status(f"\nBackups ({len(backups)} total):", "info")
    if backups:
        for b in backups[:5]:
            print_status(f"  {b['name']} ({b['size']}) - {b['date']}", "ok")
        if len(backups) > 5:
            print_status(f"  ... and {len(backups) - 5} more", "info")
    else:
        print_status("  No backups found", "warn")


def main():
    """Main entry point."""
    args = sys.argv[1:]

    if not args:
        # Default: create backup
        success = create_backup()
        sys.exit(0 if success else 1)

    command = args[0].lower()

    if command in ["restore", "r"]:
        backup_name = args[1] if len(args) > 1 else None
        success = restore_backup(backup_name)
        sys.exit(0 if success else 1)

    elif command in ["list", "l", "ls"]:
        show_status()
        sys.exit(0)

    elif command in ["auto", "a"]:
        # Only backup if database changed
        success = create_backup(force=False)
        sys.exit(0 if success else 1)

    elif command in ["force", "f"]:
        # Force backup even if unchanged
        success = create_backup(force=True)
        sys.exit(0 if success else 1)

    elif command in ["help", "h", "-h", "--help"]:
        print(__doc__)
        sys.exit(0)

    else:
        print_status(f"Unknown command: {command}", "error")
        print(__doc__)
        sys.exit(1)


if __name__ == "__main__":
    main()
